// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	db "wish-list/internal/shared/db/models"
)

// Ensure, that GiftItemRepositoryInterfaceMock does implement GiftItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ GiftItemRepositoryInterface = &GiftItemRepositoryInterfaceMock{}

// GiftItemRepositoryInterfaceMock is a mock implementation of GiftItemRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked GiftItemRepositoryInterface
//		mockedGiftItemRepositoryInterface := &GiftItemRepositoryInterfaceMock{
//			CreateFunc: func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
//				panic("mock out the Create method")
//			},
//			DeleteWithReservationNotificationFunc: func(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error) {
//				panic("mock out the DeleteWithReservationNotification method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*db.GiftItem, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) ([]*db.GiftItem, error) {
//				panic("mock out the GetByWishList method")
//			},
//			MarkAsPurchasedFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID, purchasedPrice pgtype.Numeric) (*db.GiftItem, error) {
//				panic("mock out the MarkAsPurchased method")
//			},
//			UpdateFunc: func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedGiftItemRepositoryInterface in code that requires GiftItemRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemRepositoryInterfaceMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error)

	// DeleteWithReservationNotificationFunc mocks the DeleteWithReservationNotification method.
	DeleteWithReservationNotificationFunc func(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*db.GiftItem, error)

	// GetByWishListFunc mocks the GetByWishList method.
	GetByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) ([]*db.GiftItem, error)

	// MarkAsPurchasedFunc mocks the MarkAsPurchased method.
	MarkAsPurchasedFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID, purchasedPrice pgtype.Numeric) (*db.GiftItem, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem db.GiftItem
		}
		// DeleteWithReservationNotification holds details about calls to the DeleteWithReservationNotification method.
		DeleteWithReservationNotification []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByWishList holds details about calls to the GetByWishList method.
		GetByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// MarkAsPurchased holds details about calls to the MarkAsPurchased method.
		MarkAsPurchased []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
			// PurchasedPrice is the purchasedPrice argument value.
			PurchasedPrice pgtype.Numeric
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem db.GiftItem
		}
	}
	lockCreate                            sync.RWMutex
	lockDeleteWithReservationNotification sync.RWMutex
	lockGetByID                           sync.RWMutex
	lockGetByWishList                     sync.RWMutex
	lockMarkAsPurchased                   sync.RWMutex
	lockUpdate                            sync.RWMutex
}

// Create calls CreateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Create(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
	if mock.CreateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CreateFunc: method is nil but GiftItemRepositoryInterface.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, giftItem)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CreateCalls())
func (mock *GiftItemRepositoryInterfaceMock) CreateCalls() []struct {
	Ctx      context.Context
	GiftItem db.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// DeleteWithReservationNotification calls DeleteWithReservationNotificationFunc.
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithReservationNotification(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error) {
	if mock.DeleteWithReservationNotificationFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteWithReservationNotificationFunc: method is nil but GiftItemRepositoryInterface.DeleteWithReservationNotification was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockDeleteWithReservationNotification.Lock()
	mock.calls.DeleteWithReservationNotification = append(mock.calls.DeleteWithReservationNotification, callInfo)
	mock.lockDeleteWithReservationNotification.Unlock()
	return mock.DeleteWithReservationNotificationFunc(ctx, giftItemID)
}

// DeleteWithReservationNotificationCalls gets all the calls that were made to DeleteWithReservationNotification.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteWithReservationNotificationCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithReservationNotificationCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockDeleteWithReservationNotification.RLock()
	calls = mock.calls.DeleteWithReservationNotification
	mock.lockDeleteWithReservationNotification.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*db.GiftItem, error) {
	if mock.GetByIDFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByIDFunc: method is nil but GiftItemRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByIDCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByWishList calls GetByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishList(ctx context.Context, wishlistID pgtype.UUID) ([]*db.GiftItem, error) {
	if mock.GetByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListFunc: method is nil but GiftItemRepositoryInterface.GetByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockGetByWishList.Lock()
	mock.calls.GetByWishList = append(mock.calls.GetByWishList, callInfo)
	mock.lockGetByWishList.Unlock()
	return mock.GetByWishListFunc(ctx, wishlistID)
}

// GetByWishListCalls gets all the calls that were made to GetByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockGetByWishList.RLock()
	calls = mock.calls.GetByWishList
	mock.lockGetByWishList.RUnlock()
	return calls
}

// MarkAsPurchased calls MarkAsPurchasedFunc.
func (mock *GiftItemRepositoryInterfaceMock) MarkAsPurchased(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID, purchasedPrice pgtype.Numeric) (*db.GiftItem, error) {
	if mock.MarkAsPurchasedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.MarkAsPurchasedFunc: method is nil but GiftItemRepositoryInterface.MarkAsPurchased was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		GiftItemID     pgtype.UUID
		UserID         pgtype.UUID
		PurchasedPrice pgtype.Numeric
	}{
		Ctx:            ctx,
		GiftItemID:     giftItemID,
		UserID:         userID,
		PurchasedPrice: purchasedPrice,
	}
	mock.lockMarkAsPurchased.Lock()
	mock.calls.MarkAsPurchased = append(mock.calls.MarkAsPurchased, callInfo)
	mock.lockMarkAsPurchased.Unlock()
	return mock.MarkAsPurchasedFunc(ctx, giftItemID, userID, purchasedPrice)
}

// MarkAsPurchasedCalls gets all the calls that were made to MarkAsPurchased.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.MarkAsPurchasedCalls())
func (mock *GiftItemRepositoryInterfaceMock) MarkAsPurchasedCalls() []struct {
	Ctx            context.Context
	GiftItemID     pgtype.UUID
	UserID         pgtype.UUID
	PurchasedPrice pgtype.Numeric
} {
	var calls []struct {
		Ctx            context.Context
		GiftItemID     pgtype.UUID
		UserID         pgtype.UUID
		PurchasedPrice pgtype.Numeric
	}
	mock.lockMarkAsPurchased.RLock()
	calls = mock.calls.MarkAsPurchased
	mock.lockMarkAsPurchased.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Update(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
	if mock.UpdateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateFunc: method is nil but GiftItemRepositoryInterface.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, giftItem)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateCalls() []struct {
	Ctx      context.Context
	GiftItem db.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that ReservationRepositoryInterfaceMock does implement ReservationRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ ReservationRepositoryInterface = &ReservationRepositoryInterfaceMock{}

// ReservationRepositoryInterfaceMock is a mock implementation of ReservationRepositoryInterface.
//
//	func TestSomethingThatUsesReservationRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked ReservationRepositoryInterface
//		mockedReservationRepositoryInterface := &ReservationRepositoryInterfaceMock{
//			GetActiveReservationForGiftItemFunc: func(ctx context.Context, giftItemID pgtype.UUID) (*db.Reservation, error) {
//				panic("mock out the GetActiveReservationForGiftItem method")
//			},
//		}
//
//		// use mockedReservationRepositoryInterface in code that requires ReservationRepositoryInterface
//		// and then make assertions.
//
//	}
type ReservationRepositoryInterfaceMock struct {
	// GetActiveReservationForGiftItemFunc mocks the GetActiveReservationForGiftItem method.
	GetActiveReservationForGiftItemFunc func(ctx context.Context, giftItemID pgtype.UUID) (*db.Reservation, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetActiveReservationForGiftItem holds details about calls to the GetActiveReservationForGiftItem method.
		GetActiveReservationForGiftItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
	}
	lockGetActiveReservationForGiftItem sync.RWMutex
}

// GetActiveReservationForGiftItem calls GetActiveReservationForGiftItemFunc.
func (mock *ReservationRepositoryInterfaceMock) GetActiveReservationForGiftItem(ctx context.Context, giftItemID pgtype.UUID) (*db.Reservation, error) {
	if mock.GetActiveReservationForGiftItemFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetActiveReservationForGiftItemFunc: method is nil but ReservationRepositoryInterface.GetActiveReservationForGiftItem was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockGetActiveReservationForGiftItem.Lock()
	mock.calls.GetActiveReservationForGiftItem = append(mock.calls.GetActiveReservationForGiftItem, callInfo)
	mock.lockGetActiveReservationForGiftItem.Unlock()
	return mock.GetActiveReservationForGiftItemFunc(ctx, giftItemID)
}

// GetActiveReservationForGiftItemCalls gets all the calls that were made to GetActiveReservationForGiftItem.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetActiveReservationForGiftItemCalls())
func (mock *ReservationRepositoryInterfaceMock) GetActiveReservationForGiftItemCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockGetActiveReservationForGiftItem.RLock()
	calls = mock.calls.GetActiveReservationForGiftItem
	mock.lockGetActiveReservationForGiftItem.RUnlock()
	return calls
}

// Ensure, that EmailServiceInterfaceMock does implement EmailServiceInterface.
// If this is not the case, regenerate this file with moq.
var _ EmailServiceInterface = &EmailServiceInterfaceMock{}

// EmailServiceInterfaceMock is a mock implementation of EmailServiceInterface.
//
//	func TestSomethingThatUsesEmailServiceInterface(t *testing.T) {
//
//		// make and configure a mocked EmailServiceInterface
//		mockedEmailServiceInterface := &EmailServiceInterfaceMock{
//			SendGiftPurchasedConfirmationEmailFunc: func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string, guestName string) error {
//				panic("mock out the SendGiftPurchasedConfirmationEmail method")
//			},
//			SendReservationRemovedEmailFunc: func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string) error {
//				panic("mock out the SendReservationRemovedEmail method")
//			},
//		}
//
//		// use mockedEmailServiceInterface in code that requires EmailServiceInterface
//		// and then make assertions.
//
//	}
type EmailServiceInterfaceMock struct {
	// SendGiftPurchasedConfirmationEmailFunc mocks the SendGiftPurchasedConfirmationEmail method.
	SendGiftPurchasedConfirmationEmailFunc func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string, guestName string) error

	// SendReservationRemovedEmailFunc mocks the SendReservationRemovedEmail method.
	SendReservationRemovedEmailFunc func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string) error

	// calls tracks calls to the methods.
	calls struct {
		// SendGiftPurchasedConfirmationEmail holds details about calls to the SendGiftPurchasedConfirmationEmail method.
		SendGiftPurchasedConfirmationEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RecipientEmail is the recipientEmail argument value.
			RecipientEmail string
			// GiftItemName is the giftItemName argument value.
			GiftItemName string
			// WishlistTitle is the wishlistTitle argument value.
			WishlistTitle string
			// GuestName is the guestName argument value.
			GuestName string
		}
		// SendReservationRemovedEmail holds details about calls to the SendReservationRemovedEmail method.
		SendReservationRemovedEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RecipientEmail is the recipientEmail argument value.
			RecipientEmail string
			// GiftItemName is the giftItemName argument value.
			GiftItemName string
			// WishlistTitle is the wishlistTitle argument value.
			WishlistTitle string
		}
	}
	lockSendGiftPurchasedConfirmationEmail sync.RWMutex
	lockSendReservationRemovedEmail        sync.RWMutex
}

// SendGiftPurchasedConfirmationEmail calls SendGiftPurchasedConfirmationEmailFunc.
func (mock *EmailServiceInterfaceMock) SendGiftPurchasedConfirmationEmail(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string, guestName string) error {
	if mock.SendGiftPurchasedConfirmationEmailFunc == nil {
		panic("EmailServiceInterfaceMock.SendGiftPurchasedConfirmationEmailFunc: method is nil but EmailServiceInterface.SendGiftPurchasedConfirmationEmail was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
		GuestName      string
	}{
		Ctx:            ctx,
		RecipientEmail: recipientEmail,
		GiftItemName:   giftItemName,
		WishlistTitle:  wishlistTitle,
		GuestName:      guestName,
	}
	mock.lockSendGiftPurchasedConfirmationEmail.Lock()
	mock.calls.SendGiftPurchasedConfirmationEmail = append(mock.calls.SendGiftPurchasedConfirmationEmail, callInfo)
	mock.lockSendGiftPurchasedConfirmationEmail.Unlock()
	return mock.SendGiftPurchasedConfirmationEmailFunc(ctx, recipientEmail, giftItemName, wishlistTitle, guestName)
}

// SendGiftPurchasedConfirmationEmailCalls gets all the calls that were made to SendGiftPurchasedConfirmationEmail.
// Check the length with:
//
//	len(mockedEmailServiceInterface.SendGiftPurchasedConfirmationEmailCalls())
func (mock *EmailServiceInterfaceMock) SendGiftPurchasedConfirmationEmailCalls() []struct {
	Ctx            context.Context
	RecipientEmail string
	GiftItemName   string
	WishlistTitle  string
	GuestName      string
} {
	var calls []struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
		GuestName      string
	}
	mock.lockSendGiftPurchasedConfirmationEmail.RLock()
	calls = mock.calls.SendGiftPurchasedConfirmationEmail
	mock.lockSendGiftPurchasedConfirmationEmail.RUnlock()
	return calls
}

// SendReservationRemovedEmail calls SendReservationRemovedEmailFunc.
func (mock *EmailServiceInterfaceMock) SendReservationRemovedEmail(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string) error {
	if mock.SendReservationRemovedEmailFunc == nil {
		panic("EmailServiceInterfaceMock.SendReservationRemovedEmailFunc: method is nil but EmailServiceInterface.SendReservationRemovedEmail was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
	}{
		Ctx:            ctx,
		RecipientEmail: recipientEmail,
		GiftItemName:   giftItemName,
		WishlistTitle:  wishlistTitle,
	}
	mock.lockSendReservationRemovedEmail.Lock()
	mock.calls.SendReservationRemovedEmail = append(mock.calls.SendReservationRemovedEmail, callInfo)
	mock.lockSendReservationRemovedEmail.Unlock()
	return mock.SendReservationRemovedEmailFunc(ctx, recipientEmail, giftItemName, wishlistTitle)
}

// SendReservationRemovedEmailCalls gets all the calls that were made to SendReservationRemovedEmail.
// Check the length with:
//
//	len(mockedEmailServiceInterface.SendReservationRemovedEmailCalls())
func (mock *EmailServiceInterfaceMock) SendReservationRemovedEmailCalls() []struct {
	Ctx            context.Context
	RecipientEmail string
	GiftItemName   string
	WishlistTitle  string
} {
	var calls []struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
	}
	mock.lockSendReservationRemovedEmail.RLock()
	calls = mock.calls.SendReservationRemovedEmail
	mock.lockSendReservationRemovedEmail.RUnlock()
	return calls
}

// Ensure, that CacheInterfaceMock does implement CacheInterface.
// If this is not the case, regenerate this file with moq.
var _ CacheInterface = &CacheInterfaceMock{}

// CacheInterfaceMock is a mock implementation of CacheInterface.
//
//	func TestSomethingThatUsesCacheInterface(t *testing.T) {
//
//		// make and configure a mocked CacheInterface
//		mockedCacheInterface := &CacheInterfaceMock{
//			DeleteFunc: func(ctx context.Context, key string) error {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(ctx context.Context, key string, dest any) error {
//				panic("mock out the Get method")
//			},
//			SetFunc: func(ctx context.Context, key string, value any) error {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedCacheInterface in code that requires CacheInterface
//		// and then make assertions.
//
//	}
type CacheInterfaceMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, key string) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key string, dest any) error

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, key string, value any) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Dest is the dest argument value.
			Dest any
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value any
		}
	}
	lockDelete sync.RWMutex
	lockGet    sync.RWMutex
	lockSet    sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CacheInterfaceMock) Delete(ctx context.Context, key string) error {
	if mock.DeleteFunc == nil {
		panic("CacheInterfaceMock.DeleteFunc: method is nil but CacheInterface.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedCacheInterface.DeleteCalls())
func (mock *CacheInterfaceMock) DeleteCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *CacheInterfaceMock) Get(ctx context.Context, key string, dest any) error {
	if mock.GetFunc == nil {
		panic("CacheInterfaceMock.GetFunc: method is nil but CacheInterface.Get was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Dest any
	}{
		Ctx:  ctx,
		Key:  key,
		Dest: dest,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key, dest)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedCacheInterface.GetCalls())
func (mock *CacheInterfaceMock) GetCalls() []struct {
	Ctx  context.Context
	Key  string
	Dest any
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Dest any
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *CacheInterfaceMock) Set(ctx context.Context, key string, value any) error {
	if mock.SetFunc == nil {
		panic("CacheInterfaceMock.SetFunc: method is nil but CacheInterface.Set was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value any
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, key, value)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedCacheInterface.SetCalls())
func (mock *CacheInterfaceMock) SetCalls() []struct {
	Ctx   context.Context
	Key   string
	Value any
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value any
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
