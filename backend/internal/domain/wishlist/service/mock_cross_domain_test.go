// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	itemmodels "wish-list/internal/domain/item/models"
	itemrepository "wish-list/internal/domain/item/repository"
	reservationmodels "wish-list/internal/domain/reservation/models"
)

// Ensure, that GiftItemRepositoryInterfaceMock does implement GiftItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ GiftItemRepositoryInterface = &GiftItemRepositoryInterfaceMock{}

// GiftItemRepositoryInterfaceMock is a mock implementation of GiftItemRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked GiftItemRepositoryInterface
//		mockedGiftItemRepositoryInterface := &GiftItemRepositoryInterfaceMock{
//			CreateWithOwnerFunc: func(ctx context.Context, giftItem itemmodels.GiftItem) (*itemmodels.GiftItem, error) {
//				panic("mock out the CreateWithOwner method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*itemmodels.GiftItem, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) ([]*itemmodels.GiftItem, error) {
//				panic("mock out the GetByWishList method")
//			},
//			GetPublicWishListGiftItemsPaginatedFunc: func(ctx context.Context, publicSlug string, limit int, offset int) ([]*itemmodels.GiftItem, int, error) {
//				panic("mock out the GetPublicWishListGiftItemsPaginated method")
//			},
//			GetPublicWishListGiftItemsFilteredFunc: func(ctx context.Context, publicSlug string, filters itemrepository.PublicItemFilters) ([]*itemmodels.GiftItem, int, error) {
//				panic("mock out the GetPublicWishListGiftItemsFiltered method")
//			},
//			UpdateFunc: func(ctx context.Context, giftItem itemmodels.GiftItem) (*itemmodels.GiftItem, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedGiftItemRepositoryInterface in code that requires GiftItemRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemRepositoryInterfaceMock struct {
	// CreateWithOwnerFunc mocks the CreateWithOwner method.
	CreateWithOwnerFunc func(ctx context.Context, giftItem itemmodels.GiftItem) (*itemmodels.GiftItem, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*itemmodels.GiftItem, error)

	// GetByWishListFunc mocks the GetByWishList method.
	GetByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) ([]*itemmodels.GiftItem, error)

	// GetPublicWishListGiftItemsPaginatedFunc mocks the GetPublicWishListGiftItemsPaginated method.
	GetPublicWishListGiftItemsPaginatedFunc func(ctx context.Context, publicSlug string, limit int, offset int) ([]*itemmodels.GiftItem, int, error)

	// GetPublicWishListGiftItemsFilteredFunc mocks the GetPublicWishListGiftItemsFiltered method.
	GetPublicWishListGiftItemsFilteredFunc func(ctx context.Context, publicSlug string, filters itemrepository.PublicItemFilters) ([]*itemmodels.GiftItem, int, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, giftItem itemmodels.GiftItem) (*itemmodels.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateWithOwner holds details about calls to the CreateWithOwner method.
		CreateWithOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem itemmodels.GiftItem
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByWishList holds details about calls to the GetByWishList method.
		GetByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// GetPublicWishListGiftItemsPaginated holds details about calls to the GetPublicWishListGiftItemsPaginated method.
		GetPublicWishListGiftItemsPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetPublicWishListGiftItemsFiltered holds details about calls to the GetPublicWishListGiftItemsFiltered method.
		GetPublicWishListGiftItemsFiltered []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
			// Filters is the filters argument value.
			Filters itemrepository.PublicItemFilters
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem itemmodels.GiftItem
		}
	}
	lockCreateWithOwner                    sync.RWMutex
	lockGetByID                            sync.RWMutex
	lockGetByWishList                      sync.RWMutex
	lockGetPublicWishListGiftItemsPaginated sync.RWMutex
	lockGetPublicWishListGiftItemsFiltered sync.RWMutex
	lockUpdate                             sync.RWMutex
}

// CreateWithOwner calls CreateWithOwnerFunc.
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwner(ctx context.Context, giftItem itemmodels.GiftItem) (*itemmodels.GiftItem, error) {
	if mock.CreateWithOwnerFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CreateWithOwnerFunc: method is nil but GiftItemRepositoryInterface.CreateWithOwner was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem itemmodels.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockCreateWithOwner.Lock()
	mock.calls.CreateWithOwner = append(mock.calls.CreateWithOwner, callInfo)
	mock.lockCreateWithOwner.Unlock()
	return mock.CreateWithOwnerFunc(ctx, giftItem)
}

// CreateWithOwnerCalls gets all the calls that were made to CreateWithOwner.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CreateWithOwnerCalls())
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwnerCalls() []struct {
	Ctx      context.Context
	GiftItem itemmodels.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem itemmodels.GiftItem
	}
	mock.lockCreateWithOwner.RLock()
	calls = mock.calls.CreateWithOwner
	mock.lockCreateWithOwner.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*itemmodels.GiftItem, error) {
	if mock.GetByIDFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByIDFunc: method is nil but GiftItemRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByIDCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByWishList calls GetByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishList(ctx context.Context, wishlistID pgtype.UUID) ([]*itemmodels.GiftItem, error) {
	if mock.GetByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListFunc: method is nil but GiftItemRepositoryInterface.GetByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockGetByWishList.Lock()
	mock.calls.GetByWishList = append(mock.calls.GetByWishList, callInfo)
	mock.lockGetByWishList.Unlock()
	return mock.GetByWishListFunc(ctx, wishlistID)
}

// GetByWishListCalls gets all the calls that were made to GetByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockGetByWishList.RLock()
	calls = mock.calls.GetByWishList
	mock.lockGetByWishList.RUnlock()
	return calls
}

// GetPublicWishListGiftItemsPaginated calls GetPublicWishListGiftItemsPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsPaginated(ctx context.Context, publicSlug string, limit int, offset int) ([]*itemmodels.GiftItem, int, error) {
	if mock.GetPublicWishListGiftItemsPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItemsPaginated was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
		Limit      int
		Offset     int
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
		Limit:      limit,
		Offset:     offset,
	}
	mock.lockGetPublicWishListGiftItemsPaginated.Lock()
	mock.calls.GetPublicWishListGiftItemsPaginated = append(mock.calls.GetPublicWishListGiftItemsPaginated, callInfo)
	mock.lockGetPublicWishListGiftItemsPaginated.Unlock()
	return mock.GetPublicWishListGiftItemsPaginatedFunc(ctx, publicSlug, limit, offset)
}

// GetPublicWishListGiftItemsPaginatedCalls gets all the calls that were made to GetPublicWishListGiftItemsPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsPaginatedCalls() []struct {
	Ctx        context.Context
	PublicSlug string
	Limit      int
	Offset     int
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
		Limit      int
		Offset     int
	}
	mock.lockGetPublicWishListGiftItemsPaginated.RLock()
	calls = mock.calls.GetPublicWishListGiftItemsPaginated
	mock.lockGetPublicWishListGiftItemsPaginated.RUnlock()
	return calls
}

// GetPublicWishListGiftItemsFiltered calls GetPublicWishListGiftItemsFilteredFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsFiltered(ctx context.Context, publicSlug string, filters itemrepository.PublicItemFilters) ([]*itemmodels.GiftItem, int, error) {
	if mock.GetPublicWishListGiftItemsFilteredFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsFilteredFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItemsFiltered was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
		Filters    itemrepository.PublicItemFilters
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
		Filters:    filters,
	}
	mock.lockGetPublicWishListGiftItemsFiltered.Lock()
	mock.calls.GetPublicWishListGiftItemsFiltered = append(mock.calls.GetPublicWishListGiftItemsFiltered, callInfo)
	mock.lockGetPublicWishListGiftItemsFiltered.Unlock()
	return mock.GetPublicWishListGiftItemsFilteredFunc(ctx, publicSlug, filters)
}

// GetPublicWishListGiftItemsFilteredCalls gets all the calls that were made to GetPublicWishListGiftItemsFiltered.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsFilteredCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsFilteredCalls() []struct {
	Ctx        context.Context
	PublicSlug string
	Filters    itemrepository.PublicItemFilters
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
		Filters    itemrepository.PublicItemFilters
	}
	mock.lockGetPublicWishListGiftItemsFiltered.RLock()
	calls = mock.calls.GetPublicWishListGiftItemsFiltered
	mock.lockGetPublicWishListGiftItemsFiltered.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Update(ctx context.Context, giftItem itemmodels.GiftItem) (*itemmodels.GiftItem, error) {
	if mock.UpdateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateFunc: method is nil but GiftItemRepositoryInterface.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem itemmodels.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, giftItem)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateCalls() []struct {
	Ctx      context.Context
	GiftItem itemmodels.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem itemmodels.GiftItem
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that ReservationRepositoryInterfaceMock does implement ReservationRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ ReservationRepositoryInterface = &ReservationRepositoryInterfaceMock{}

// ReservationRepositoryInterfaceMock is a mock implementation of ReservationRepositoryInterface.
//
//	func TestSomethingThatUsesReservationRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked ReservationRepositoryInterface
//		mockedReservationRepositoryInterface := &ReservationRepositoryInterfaceMock{
//			GetActiveReservationForGiftItemFunc: func(ctx context.Context, giftItemID pgtype.UUID) (*reservationmodels.Reservation, error) {
//				panic("mock out the GetActiveReservationForGiftItem method")
//			},
//		}
//
//		// use mockedReservationRepositoryInterface in code that requires ReservationRepositoryInterface
//		// and then make assertions.
//
//	}
type ReservationRepositoryInterfaceMock struct {
	// GetActiveReservationForGiftItemFunc mocks the GetActiveReservationForGiftItem method.
	GetActiveReservationForGiftItemFunc func(ctx context.Context, giftItemID pgtype.UUID) (*reservationmodels.Reservation, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetActiveReservationForGiftItem holds details about calls to the GetActiveReservationForGiftItem method.
		GetActiveReservationForGiftItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
	}
	lockGetActiveReservationForGiftItem sync.RWMutex
}

// GetActiveReservationForGiftItem calls GetActiveReservationForGiftItemFunc.
func (mock *ReservationRepositoryInterfaceMock) GetActiveReservationForGiftItem(ctx context.Context, giftItemID pgtype.UUID) (*reservationmodels.Reservation, error) {
	if mock.GetActiveReservationForGiftItemFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetActiveReservationForGiftItemFunc: method is nil but ReservationRepositoryInterface.GetActiveReservationForGiftItem was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockGetActiveReservationForGiftItem.Lock()
	mock.calls.GetActiveReservationForGiftItem = append(mock.calls.GetActiveReservationForGiftItem, callInfo)
	mock.lockGetActiveReservationForGiftItem.Unlock()
	return mock.GetActiveReservationForGiftItemFunc(ctx, giftItemID)
}

// GetActiveReservationForGiftItemCalls gets all the calls that were made to GetActiveReservationForGiftItem.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetActiveReservationForGiftItemCalls())
func (mock *ReservationRepositoryInterfaceMock) GetActiveReservationForGiftItemCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockGetActiveReservationForGiftItem.RLock()
	calls = mock.calls.GetActiveReservationForGiftItem
	mock.lockGetActiveReservationForGiftItem.RUnlock()
	return calls
}

// Ensure, that EmailServiceInterfaceMock does implement EmailServiceInterface.
// If this is not the case, regenerate this file with moq.
var _ EmailServiceInterface = &EmailServiceInterfaceMock{}

// EmailServiceInterfaceMock is a mock implementation of EmailServiceInterface.
//
//	func TestSomethingThatUsesEmailServiceInterface(t *testing.T) {
//
//		// make and configure a mocked EmailServiceInterface
//		mockedEmailServiceInterface := &EmailServiceInterfaceMock{
//			SendGiftPurchasedConfirmationEmailFunc: func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string, guestName string) error {
//				panic("mock out the SendGiftPurchasedConfirmationEmail method")
//			},
//			SendReservationRemovedEmailFunc: func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string) error {
//				panic("mock out the SendReservationRemovedEmail method")
//			},
//		}
//
//		// use mockedEmailServiceInterface in code that requires EmailServiceInterface
//		// and then make assertions.
//
//	}
type EmailServiceInterfaceMock struct {
	// SendGiftPurchasedConfirmationEmailFunc mocks the SendGiftPurchasedConfirmationEmail method.
	SendGiftPurchasedConfirmationEmailFunc func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string, guestName string) error

	// SendReservationRemovedEmailFunc mocks the SendReservationRemovedEmail method.
	SendReservationRemovedEmailFunc func(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string) error

	// calls tracks calls to the methods.
	calls struct {
		// SendGiftPurchasedConfirmationEmail holds details about calls to the SendGiftPurchasedConfirmationEmail method.
		SendGiftPurchasedConfirmationEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RecipientEmail is the recipientEmail argument value.
			RecipientEmail string
			// GiftItemName is the giftItemName argument value.
			GiftItemName string
			// WishlistTitle is the wishlistTitle argument value.
			WishlistTitle string
			// GuestName is the guestName argument value.
			GuestName string
		}
		// SendReservationRemovedEmail holds details about calls to the SendReservationRemovedEmail method.
		SendReservationRemovedEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RecipientEmail is the recipientEmail argument value.
			RecipientEmail string
			// GiftItemName is the giftItemName argument value.
			GiftItemName string
			// WishlistTitle is the wishlistTitle argument value.
			WishlistTitle string
		}
	}
	lockSendGiftPurchasedConfirmationEmail sync.RWMutex
	lockSendReservationRemovedEmail        sync.RWMutex
}

// SendGiftPurchasedConfirmationEmail calls SendGiftPurchasedConfirmationEmailFunc.
func (mock *EmailServiceInterfaceMock) SendGiftPurchasedConfirmationEmail(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string, guestName string) error {
	if mock.SendGiftPurchasedConfirmationEmailFunc == nil {
		panic("EmailServiceInterfaceMock.SendGiftPurchasedConfirmationEmailFunc: method is nil but EmailServiceInterface.SendGiftPurchasedConfirmationEmail was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
		GuestName      string
	}{
		Ctx:            ctx,
		RecipientEmail: recipientEmail,
		GiftItemName:   giftItemName,
		WishlistTitle:  wishlistTitle,
		GuestName:      guestName,
	}
	mock.lockSendGiftPurchasedConfirmationEmail.Lock()
	mock.calls.SendGiftPurchasedConfirmationEmail = append(mock.calls.SendGiftPurchasedConfirmationEmail, callInfo)
	mock.lockSendGiftPurchasedConfirmationEmail.Unlock()
	return mock.SendGiftPurchasedConfirmationEmailFunc(ctx, recipientEmail, giftItemName, wishlistTitle, guestName)
}

// SendGiftPurchasedConfirmationEmailCalls gets all the calls that were made to SendGiftPurchasedConfirmationEmail.
// Check the length with:
//
//	len(mockedEmailServiceInterface.SendGiftPurchasedConfirmationEmailCalls())
func (mock *EmailServiceInterfaceMock) SendGiftPurchasedConfirmationEmailCalls() []struct {
	Ctx            context.Context
	RecipientEmail string
	GiftItemName   string
	WishlistTitle  string
	GuestName      string
} {
	var calls []struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
		GuestName      string
	}
	mock.lockSendGiftPurchasedConfirmationEmail.RLock()
	calls = mock.calls.SendGiftPurchasedConfirmationEmail
	mock.lockSendGiftPurchasedConfirmationEmail.RUnlock()
	return calls
}

// SendReservationRemovedEmail calls SendReservationRemovedEmailFunc.
func (mock *EmailServiceInterfaceMock) SendReservationRemovedEmail(ctx context.Context, recipientEmail string, giftItemName string, wishlistTitle string) error {
	if mock.SendReservationRemovedEmailFunc == nil {
		panic("EmailServiceInterfaceMock.SendReservationRemovedEmailFunc: method is nil but EmailServiceInterface.SendReservationRemovedEmail was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
	}{
		Ctx:            ctx,
		RecipientEmail: recipientEmail,
		GiftItemName:   giftItemName,
		WishlistTitle:  wishlistTitle,
	}
	mock.lockSendReservationRemovedEmail.Lock()
	mock.calls.SendReservationRemovedEmail = append(mock.calls.SendReservationRemovedEmail, callInfo)
	mock.lockSendReservationRemovedEmail.Unlock()
	return mock.SendReservationRemovedEmailFunc(ctx, recipientEmail, giftItemName, wishlistTitle)
}

// SendReservationRemovedEmailCalls gets all the calls that were made to SendReservationRemovedEmail.
// Check the length with:
//
//	len(mockedEmailServiceInterface.SendReservationRemovedEmailCalls())
func (mock *EmailServiceInterfaceMock) SendReservationRemovedEmailCalls() []struct {
	Ctx            context.Context
	RecipientEmail string
	GiftItemName   string
	WishlistTitle  string
} {
	var calls []struct {
		Ctx            context.Context
		RecipientEmail string
		GiftItemName   string
		WishlistTitle  string
	}
	mock.lockSendReservationRemovedEmail.RLock()
	calls = mock.calls.SendReservationRemovedEmail
	mock.lockSendReservationRemovedEmail.RUnlock()
	return calls
}

// Ensure, that CacheInterfaceMock does implement CacheInterface.
// If this is not the case, regenerate this file with moq.
var _ CacheInterface = &CacheInterfaceMock{}

// CacheInterfaceMock is a mock implementation of CacheInterface.
//
//	func TestSomethingThatUsesCacheInterface(t *testing.T) {
//
//		// make and configure a mocked CacheInterface
//		mockedCacheInterface := &CacheInterfaceMock{
//			DeleteFunc: func(ctx context.Context, key string) error {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(ctx context.Context, key string, dest any) error {
//				panic("mock out the Get method")
//			},
//			SetFunc: func(ctx context.Context, key string, value any) error {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedCacheInterface in code that requires CacheInterface
//		// and then make assertions.
//
//	}
type CacheInterfaceMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, key string) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key string, dest any) error

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, key string, value any) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Dest is the dest argument value.
			Dest any
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value any
		}
	}
	lockDelete sync.RWMutex
	lockGet    sync.RWMutex
	lockSet    sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CacheInterfaceMock) Delete(ctx context.Context, key string) error {
	if mock.DeleteFunc == nil {
		panic("CacheInterfaceMock.DeleteFunc: method is nil but CacheInterface.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedCacheInterface.DeleteCalls())
func (mock *CacheInterfaceMock) DeleteCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *CacheInterfaceMock) Get(ctx context.Context, key string, dest any) error {
	if mock.GetFunc == nil {
		panic("CacheInterfaceMock.GetFunc: method is nil but CacheInterface.Get was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Dest any
	}{
		Ctx:  ctx,
		Key:  key,
		Dest: dest,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key, dest)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedCacheInterface.GetCalls())
func (mock *CacheInterfaceMock) GetCalls() []struct {
	Ctx  context.Context
	Key  string
	Dest any
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Dest any
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *CacheInterfaceMock) Set(ctx context.Context, key string, value any) error {
	if mock.SetFunc == nil {
		panic("CacheInterfaceMock.SetFunc: method is nil but CacheInterface.Set was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value any
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, key, value)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedCacheInterface.SetCalls())
func (mock *CacheInterfaceMock) SetCalls() []struct {
	Ctx   context.Context
	Key   string
	Value any
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value any
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
