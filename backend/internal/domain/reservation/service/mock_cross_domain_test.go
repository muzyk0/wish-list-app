// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	itemmodels "wish-list/internal/domain/item/models"
)

// Ensure, that GiftItemRepositoryInterfaceMock does implement GiftItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ GiftItemRepositoryInterface = &GiftItemRepositoryInterfaceMock{}

// GiftItemRepositoryInterfaceMock is a mock implementation of GiftItemRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked GiftItemRepositoryInterface
//		mockedGiftItemRepositoryInterface := &GiftItemRepositoryInterfaceMock{
//			GetByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) ([]*itemmodels.GiftItem, error) {
//				panic("mock out the GetByWishList method")
//			},
//			GetPublicWishListGiftItemsFunc: func(ctx context.Context, publicSlug string) ([]*itemmodels.GiftItem, error) {
//				panic("mock out the GetPublicWishListGiftItems method")
//			},
//			ReserveIfNotReservedFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*itemmodels.GiftItem, error) {
//				panic("mock out the ReserveIfNotReserved method")
//			},
//		}
//
//		// use mockedGiftItemRepositoryInterface in code that requires GiftItemRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemRepositoryInterfaceMock struct {
	// GetByWishListFunc mocks the GetByWishList method.
	GetByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) ([]*itemmodels.GiftItem, error)

	// GetPublicWishListGiftItemsFunc mocks the GetPublicWishListGiftItems method.
	GetPublicWishListGiftItemsFunc func(ctx context.Context, publicSlug string) ([]*itemmodels.GiftItem, error)

	// ReserveIfNotReservedFunc mocks the ReserveIfNotReserved method.
	ReserveIfNotReservedFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*itemmodels.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetByWishList holds details about calls to the GetByWishList method.
		GetByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// GetPublicWishListGiftItems holds details about calls to the GetPublicWishListGiftItems method.
		GetPublicWishListGiftItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
		}
		// ReserveIfNotReserved holds details about calls to the ReserveIfNotReserved method.
		ReserveIfNotReserved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
	}
	lockGetByWishList              sync.RWMutex
	lockGetPublicWishListGiftItems sync.RWMutex
	lockReserveIfNotReserved       sync.RWMutex
}

// GetByWishList calls GetByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishList(ctx context.Context, wishlistID pgtype.UUID) ([]*itemmodels.GiftItem, error) {
	if mock.GetByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListFunc: method is nil but GiftItemRepositoryInterface.GetByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockGetByWishList.Lock()
	mock.calls.GetByWishList = append(mock.calls.GetByWishList, callInfo)
	mock.lockGetByWishList.Unlock()
	return mock.GetByWishListFunc(ctx, wishlistID)
}

// GetByWishListCalls gets all the calls that were made to GetByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockGetByWishList.RLock()
	calls = mock.calls.GetByWishList
	mock.lockGetByWishList.RUnlock()
	return calls
}

// GetPublicWishListGiftItems calls GetPublicWishListGiftItemsFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItems(ctx context.Context, publicSlug string) ([]*itemmodels.GiftItem, error) {
	if mock.GetPublicWishListGiftItemsFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItems was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
	}
	mock.lockGetPublicWishListGiftItems.Lock()
	mock.calls.GetPublicWishListGiftItems = append(mock.calls.GetPublicWishListGiftItems, callInfo)
	mock.lockGetPublicWishListGiftItems.Unlock()
	return mock.GetPublicWishListGiftItemsFunc(ctx, publicSlug)
}

// GetPublicWishListGiftItemsCalls gets all the calls that were made to GetPublicWishListGiftItems.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsCalls() []struct {
	Ctx        context.Context
	PublicSlug string
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
	}
	mock.lockGetPublicWishListGiftItems.RLock()
	calls = mock.calls.GetPublicWishListGiftItems
	mock.lockGetPublicWishListGiftItems.RUnlock()
	return calls
}

// ReserveIfNotReserved calls ReserveIfNotReservedFunc.
func (mock *GiftItemRepositoryInterfaceMock) ReserveIfNotReserved(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*itemmodels.GiftItem, error) {
	if mock.ReserveIfNotReservedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.ReserveIfNotReservedFunc: method is nil but GiftItemRepositoryInterface.ReserveIfNotReserved was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
		UserID:     userID,
	}
	mock.lockReserveIfNotReserved.Lock()
	mock.calls.ReserveIfNotReserved = append(mock.calls.ReserveIfNotReserved, callInfo)
	mock.lockReserveIfNotReserved.Unlock()
	return mock.ReserveIfNotReservedFunc(ctx, giftItemID, userID)
}

// ReserveIfNotReservedCalls gets all the calls that were made to ReserveIfNotReserved.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.ReserveIfNotReservedCalls())
func (mock *GiftItemRepositoryInterfaceMock) ReserveIfNotReservedCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
	UserID     pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}
	mock.lockReserveIfNotReserved.RLock()
	calls = mock.calls.ReserveIfNotReserved
	mock.lockReserveIfNotReserved.RUnlock()
	return calls
}
