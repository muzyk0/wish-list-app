// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	"wish-list/internal/app/database"
	"wish-list/internal/domain/item/models"
	"wish-list/internal/domain/item/repository"
)

// Ensure, that GiftItemRepositoryInterfaceMock does implement repository.GiftItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repository.GiftItemRepositoryInterface = &GiftItemRepositoryInterfaceMock{}

// GiftItemRepositoryInterfaceMock is a mock implementation of repository.GiftItemRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repository.GiftItemRepositoryInterface
//		mockedGiftItemRepositoryInterface := &GiftItemRepositoryInterfaceMock{
//			CountByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) (int64, error) {
//				panic("mock out the CountByWishList method")
//			},
//			CreateWithOwnerFunc: func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
//				panic("mock out the CreateWithOwner method")
//			},
//			DeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the Delete method")
//			},
//			DeleteWithExecutorFunc: func(ctx context.Context, executor database.Executor, id pgtype.UUID) error {
//				panic("mock out the DeleteWithExecutor method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*models.GiftItem, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByOwnerPaginatedFunc: func(ctx context.Context, ownerID pgtype.UUID, filters repository.ItemFilters) (*repository.PaginatedResult, error) {
//				panic("mock out the GetByOwnerPaginated method")
//			},
//			GetByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) ([]*models.GiftItem, error) {
//				panic("mock out the GetByWishList method")
//			},
//			GetByWishListPaginatedFunc: func(ctx context.Context, wishlistID pgtype.UUID, page int, limit int) ([]*models.GiftItem, error) {
//				panic("mock out the GetByWishListPaginated method")
//			},
//			GetPublicWishListGiftItemsFunc: func(ctx context.Context, publicSlug string) ([]*models.GiftItem, error) {
//				panic("mock out the GetPublicWishListGiftItems method")
//			},
//			GetPublicWishListGiftItemsPaginatedFunc: func(ctx context.Context, publicSlug string, limit int, offset int) ([]*models.GiftItem, int, error) {
//				panic("mock out the GetPublicWishListGiftItemsPaginated method")
//			},
//			GetPublicWishListGiftItemsFilteredFunc: func(ctx context.Context, publicSlug string, filters repository.PublicItemFilters) ([]*models.GiftItem, int, error) {
//				panic("mock out the GetPublicWishListGiftItemsFiltered method")
//			},
//			GetStatsFunc: func(ctx context.Context, ownerID pgtype.UUID) (*repository.ItemStats, error) {
//				panic("mock out the GetStats method")
//			},
//			GetUnattachedFunc: func(ctx context.Context, ownerID pgtype.UUID) ([]*models.GiftItem, error) {
//				panic("mock out the GetUnattached method")
//			},
//			MarkManualReservationFunc: func(ctx context.Context, itemID pgtype.UUID, reservedByName string, note *string) (*models.GiftItem, error) {
//				panic("mock out the MarkManualReservation method")
//			},
//			SoftDeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the SoftDelete method")
//			},
//			UpdateFunc: func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
//				panic("mock out the Update method")
//			},
//			UpdateWithNewSchemaFunc: func(ctx context.Context, giftItem *models.GiftItem) (*models.GiftItem, error) {
//				panic("mock out the UpdateWithNewSchema method")
//			},
//		}
//
//		// use mockedGiftItemRepositoryInterface in code that requires repository.GiftItemRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemRepositoryInterfaceMock struct {
	// CountByWishListFunc mocks the CountByWishList method.
	CountByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) (int64, error)

	// CreateWithOwnerFunc mocks the CreateWithOwner method.
	CreateWithOwnerFunc func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteWithExecutorFunc mocks the DeleteWithExecutor method.
	DeleteWithExecutorFunc func(ctx context.Context, executor database.Executor, id pgtype.UUID) error

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*models.GiftItem, error)

	// GetByOwnerPaginatedFunc mocks the GetByOwnerPaginated method.
	GetByOwnerPaginatedFunc func(ctx context.Context, ownerID pgtype.UUID, filters repository.ItemFilters) (*repository.PaginatedResult, error)

	// GetByWishListFunc mocks the GetByWishList method.
	GetByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) ([]*models.GiftItem, error)

	// GetByWishListPaginatedFunc mocks the GetByWishListPaginated method.
	GetByWishListPaginatedFunc func(ctx context.Context, wishlistID pgtype.UUID, page int, limit int) ([]*models.GiftItem, error)

	// GetPublicWishListGiftItemsFunc mocks the GetPublicWishListGiftItems method.
	GetPublicWishListGiftItemsFunc func(ctx context.Context, publicSlug string) ([]*models.GiftItem, error)

	// GetPublicWishListGiftItemsPaginatedFunc mocks the GetPublicWishListGiftItemsPaginated method.
	GetPublicWishListGiftItemsPaginatedFunc func(ctx context.Context, publicSlug string, limit int, offset int) ([]*models.GiftItem, int, error)

	// GetPublicWishListGiftItemsFilteredFunc mocks the GetPublicWishListGiftItemsFiltered method.
	GetPublicWishListGiftItemsFilteredFunc func(ctx context.Context, publicSlug string, filters repository.PublicItemFilters) ([]*models.GiftItem, int, error)

	// GetStatsFunc mocks the GetStats method.
	GetStatsFunc func(ctx context.Context, ownerID pgtype.UUID) (*repository.ItemStats, error)

	// GetUnattachedFunc mocks the GetUnattached method.
	GetUnattachedFunc func(ctx context.Context, ownerID pgtype.UUID) ([]*models.GiftItem, error)

	// MarkManualReservationFunc mocks the MarkManualReservation method.
	MarkManualReservationFunc func(ctx context.Context, itemID pgtype.UUID, reservedByName string, note *string) (*models.GiftItem, error)

	// SoftDeleteFunc mocks the SoftDelete method.
	SoftDeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error)

	// UpdateWithNewSchemaFunc mocks the UpdateWithNewSchema method.
	UpdateWithNewSchemaFunc func(ctx context.Context, giftItem *models.GiftItem) (*models.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountByWishList holds details about calls to the CountByWishList method.
		CountByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// CreateWithOwner holds details about calls to the CreateWithOwner method.
		CreateWithOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem models.GiftItem
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteWithExecutor holds details about calls to the DeleteWithExecutor method.
		DeleteWithExecutor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Executor is the executor argument value.
			Executor database.Executor
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByOwnerPaginated holds details about calls to the GetByOwnerPaginated method.
		GetByOwnerPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
			// Filters is the filters argument value.
			Filters repository.ItemFilters
		}
		// GetByWishList holds details about calls to the GetByWishList method.
		GetByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// GetByWishListPaginated holds details about calls to the GetByWishListPaginated method.
		GetByWishListPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
			// Page is the page argument value.
			Page int
			// Limit is the limit argument value.
			Limit int
		}
		// GetPublicWishListGiftItems holds details about calls to the GetPublicWishListGiftItems method.
		GetPublicWishListGiftItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
		}
		// GetPublicWishListGiftItemsPaginated holds details about calls to the GetPublicWishListGiftItemsPaginated method.
		GetPublicWishListGiftItemsPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetPublicWishListGiftItemsFiltered holds details about calls to the GetPublicWishListGiftItemsFiltered method.
		GetPublicWishListGiftItemsFiltered []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
			// Filters is the filters argument value.
			Filters repository.PublicItemFilters
		}
		// GetStats holds details about calls to the GetStats method.
		GetStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
		}
		// GetUnattached holds details about calls to the GetUnattached method.
		GetUnattached []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
		}
		// MarkManualReservation holds details about calls to the MarkManualReservation method.
		MarkManualReservation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ItemID is the itemID argument value.
			ItemID pgtype.UUID
			// ReservedByName is the reservedByName argument value.
			ReservedByName string
			// Note is the note argument value.
			Note *string
		}
		// SoftDelete holds details about calls to the SoftDelete method.
		SoftDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem models.GiftItem
		}
		// UpdateWithNewSchema holds details about calls to the UpdateWithNewSchema method.
		UpdateWithNewSchema []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem *models.GiftItem
		}
	}
	lockCountByWishList                     sync.RWMutex
	lockCreateWithOwner                     sync.RWMutex
	lockDelete                              sync.RWMutex
	lockDeleteWithExecutor                  sync.RWMutex
	lockGetByID                             sync.RWMutex
	lockGetByOwnerPaginated                 sync.RWMutex
	lockGetByWishList                       sync.RWMutex
	lockGetByWishListPaginated              sync.RWMutex
	lockGetPublicWishListGiftItems          sync.RWMutex
	lockGetPublicWishListGiftItemsPaginated sync.RWMutex
	lockGetPublicWishListGiftItemsFiltered  sync.RWMutex
	lockGetStats                            sync.RWMutex
	lockGetUnattached                       sync.RWMutex
	lockMarkManualReservation               sync.RWMutex
	lockSoftDelete                          sync.RWMutex
	lockUpdate                              sync.RWMutex
	lockUpdateWithNewSchema                 sync.RWMutex
}

// CountByWishList calls CountByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) CountByWishList(ctx context.Context, wishlistID pgtype.UUID) (int64, error) {
	if mock.CountByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CountByWishListFunc: method is nil but GiftItemRepositoryInterface.CountByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockCountByWishList.Lock()
	mock.calls.CountByWishList = append(mock.calls.CountByWishList, callInfo)
	mock.lockCountByWishList.Unlock()
	return mock.CountByWishListFunc(ctx, wishlistID)
}

// CountByWishListCalls gets all the calls that were made to CountByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CountByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) CountByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockCountByWishList.RLock()
	calls = mock.calls.CountByWishList
	mock.lockCountByWishList.RUnlock()
	return calls
}

// CreateWithOwner calls CreateWithOwnerFunc.
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwner(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
	if mock.CreateWithOwnerFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CreateWithOwnerFunc: method is nil but GiftItemRepositoryInterface.CreateWithOwner was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockCreateWithOwner.Lock()
	mock.calls.CreateWithOwner = append(mock.calls.CreateWithOwner, callInfo)
	mock.lockCreateWithOwner.Unlock()
	return mock.CreateWithOwnerFunc(ctx, giftItem)
}

// CreateWithOwnerCalls gets all the calls that were made to CreateWithOwner.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CreateWithOwnerCalls())
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwnerCalls() []struct {
	Ctx      context.Context
	GiftItem models.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}
	mock.lockCreateWithOwner.RLock()
	calls = mock.calls.CreateWithOwner
	mock.lockCreateWithOwner.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *GiftItemRepositoryInterfaceMock) Delete(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteFunc: method is nil but GiftItemRepositoryInterface.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteWithExecutor calls DeleteWithExecutorFunc.
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithExecutor(ctx context.Context, executor database.Executor, id pgtype.UUID) error {
	if mock.DeleteWithExecutorFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteWithExecutorFunc: method is nil but GiftItemRepositoryInterface.DeleteWithExecutor was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Executor database.Executor
		ID       pgtype.UUID
	}{
		Ctx:      ctx,
		Executor: executor,
		ID:       id,
	}
	mock.lockDeleteWithExecutor.Lock()
	mock.calls.DeleteWithExecutor = append(mock.calls.DeleteWithExecutor, callInfo)
	mock.lockDeleteWithExecutor.Unlock()
	return mock.DeleteWithExecutorFunc(ctx, executor, id)
}

// DeleteWithExecutorCalls gets all the calls that were made to DeleteWithExecutor.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteWithExecutorCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithExecutorCalls() []struct {
	Ctx      context.Context
	Executor database.Executor
	ID       pgtype.UUID
} {
	var calls []struct {
		Ctx      context.Context
		Executor database.Executor
		ID       pgtype.UUID
	}
	mock.lockDeleteWithExecutor.RLock()
	calls = mock.calls.DeleteWithExecutor
	mock.lockDeleteWithExecutor.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*models.GiftItem, error) {
	if mock.GetByIDFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByIDFunc: method is nil but GiftItemRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByIDCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByOwnerPaginated calls GetByOwnerPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByOwnerPaginated(ctx context.Context, ownerID pgtype.UUID, filters repository.ItemFilters) (*repository.PaginatedResult, error) {
	if mock.GetByOwnerPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByOwnerPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetByOwnerPaginated was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
		Filters repository.ItemFilters
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
		Filters: filters,
	}
	mock.lockGetByOwnerPaginated.Lock()
	mock.calls.GetByOwnerPaginated = append(mock.calls.GetByOwnerPaginated, callInfo)
	mock.lockGetByOwnerPaginated.Unlock()
	return mock.GetByOwnerPaginatedFunc(ctx, ownerID, filters)
}

// GetByOwnerPaginatedCalls gets all the calls that were made to GetByOwnerPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByOwnerPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByOwnerPaginatedCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
	Filters repository.ItemFilters
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
		Filters repository.ItemFilters
	}
	mock.lockGetByOwnerPaginated.RLock()
	calls = mock.calls.GetByOwnerPaginated
	mock.lockGetByOwnerPaginated.RUnlock()
	return calls
}

// GetByWishList calls GetByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishList(ctx context.Context, wishlistID pgtype.UUID) ([]*models.GiftItem, error) {
	if mock.GetByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListFunc: method is nil but GiftItemRepositoryInterface.GetByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockGetByWishList.Lock()
	mock.calls.GetByWishList = append(mock.calls.GetByWishList, callInfo)
	mock.lockGetByWishList.Unlock()
	return mock.GetByWishListFunc(ctx, wishlistID)
}

// GetByWishListCalls gets all the calls that were made to GetByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockGetByWishList.RLock()
	calls = mock.calls.GetByWishList
	mock.lockGetByWishList.RUnlock()
	return calls
}

// GetByWishListPaginated calls GetByWishListPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListPaginated(ctx context.Context, wishlistID pgtype.UUID, page int, limit int) ([]*models.GiftItem, error) {
	if mock.GetByWishListPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetByWishListPaginated was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
		Page       int
		Limit      int
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
		Page:       page,
		Limit:      limit,
	}
	mock.lockGetByWishListPaginated.Lock()
	mock.calls.GetByWishListPaginated = append(mock.calls.GetByWishListPaginated, callInfo)
	mock.lockGetByWishListPaginated.Unlock()
	return mock.GetByWishListPaginatedFunc(ctx, wishlistID, page, limit)
}

// GetByWishListPaginatedCalls gets all the calls that were made to GetByWishListPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListPaginatedCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
	Page       int
	Limit      int
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
		Page       int
		Limit      int
	}
	mock.lockGetByWishListPaginated.RLock()
	calls = mock.calls.GetByWishListPaginated
	mock.lockGetByWishListPaginated.RUnlock()
	return calls
}

// GetPublicWishListGiftItems calls GetPublicWishListGiftItemsFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItems(ctx context.Context, publicSlug string) ([]*models.GiftItem, error) {
	if mock.GetPublicWishListGiftItemsFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItems was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
	}
	mock.lockGetPublicWishListGiftItems.Lock()
	mock.calls.GetPublicWishListGiftItems = append(mock.calls.GetPublicWishListGiftItems, callInfo)
	mock.lockGetPublicWishListGiftItems.Unlock()
	return mock.GetPublicWishListGiftItemsFunc(ctx, publicSlug)
}

// GetPublicWishListGiftItemsCalls gets all the calls that were made to GetPublicWishListGiftItems.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsCalls() []struct {
	Ctx        context.Context
	PublicSlug string
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
	}
	mock.lockGetPublicWishListGiftItems.RLock()
	calls = mock.calls.GetPublicWishListGiftItems
	mock.lockGetPublicWishListGiftItems.RUnlock()
	return calls
}

// GetPublicWishListGiftItemsPaginated calls GetPublicWishListGiftItemsPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsPaginated(ctx context.Context, publicSlug string, limit int, offset int) ([]*models.GiftItem, int, error) {
	if mock.GetPublicWishListGiftItemsPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItemsPaginated was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
		Limit      int
		Offset     int
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
		Limit:      limit,
		Offset:     offset,
	}
	mock.lockGetPublicWishListGiftItemsPaginated.Lock()
	mock.calls.GetPublicWishListGiftItemsPaginated = append(mock.calls.GetPublicWishListGiftItemsPaginated, callInfo)
	mock.lockGetPublicWishListGiftItemsPaginated.Unlock()
	return mock.GetPublicWishListGiftItemsPaginatedFunc(ctx, publicSlug, limit, offset)
}

// GetPublicWishListGiftItemsPaginatedCalls gets all the calls that were made to GetPublicWishListGiftItemsPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsPaginatedCalls() []struct {
	Ctx        context.Context
	PublicSlug string
	Limit      int
	Offset     int
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
		Limit      int
		Offset     int
	}
	mock.lockGetPublicWishListGiftItemsPaginated.RLock()
	calls = mock.calls.GetPublicWishListGiftItemsPaginated
	mock.lockGetPublicWishListGiftItemsPaginated.RUnlock()
	return calls
}

// GetPublicWishListGiftItemsFiltered calls GetPublicWishListGiftItemsFilteredFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsFiltered(ctx context.Context, publicSlug string, filters repository.PublicItemFilters) ([]*models.GiftItem, int, error) {
	if mock.GetPublicWishListGiftItemsFilteredFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsFilteredFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItemsFiltered was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
		Filters    repository.PublicItemFilters
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
		Filters:    filters,
	}
	mock.lockGetPublicWishListGiftItemsFiltered.Lock()
	mock.calls.GetPublicWishListGiftItemsFiltered = append(mock.calls.GetPublicWishListGiftItemsFiltered, callInfo)
	mock.lockGetPublicWishListGiftItemsFiltered.Unlock()
	return mock.GetPublicWishListGiftItemsFilteredFunc(ctx, publicSlug, filters)
}

// GetPublicWishListGiftItemsFilteredCalls gets all the calls that were made to GetPublicWishListGiftItemsFiltered.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsFilteredCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsFilteredCalls() []struct {
	Ctx        context.Context
	PublicSlug string
	Filters    repository.PublicItemFilters
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
		Filters    repository.PublicItemFilters
	}
	mock.lockGetPublicWishListGiftItemsFiltered.RLock()
	calls = mock.calls.GetPublicWishListGiftItemsFiltered
	mock.lockGetPublicWishListGiftItemsFiltered.RUnlock()
	return calls
}

// GetStats calls GetStatsFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetStats(ctx context.Context, ownerID pgtype.UUID) (*repository.ItemStats, error) {
	if mock.GetStatsFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetStatsFunc: method is nil but GiftItemRepositoryInterface.GetStats was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
	}
	mock.lockGetStats.Lock()
	mock.calls.GetStats = append(mock.calls.GetStats, callInfo)
	mock.lockGetStats.Unlock()
	return mock.GetStatsFunc(ctx, ownerID)
}

// GetStatsCalls gets all the calls that were made to GetStats.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetStatsCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetStatsCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}
	mock.lockGetStats.RLock()
	calls = mock.calls.GetStats
	mock.lockGetStats.RUnlock()
	return calls
}

// GetUnattached calls GetUnattachedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetUnattached(ctx context.Context, ownerID pgtype.UUID) ([]*models.GiftItem, error) {
	if mock.GetUnattachedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetUnattachedFunc: method is nil but GiftItemRepositoryInterface.GetUnattached was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
	}
	mock.lockGetUnattached.Lock()
	mock.calls.GetUnattached = append(mock.calls.GetUnattached, callInfo)
	mock.lockGetUnattached.Unlock()
	return mock.GetUnattachedFunc(ctx, ownerID)
}

// GetUnattachedCalls gets all the calls that were made to GetUnattached.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetUnattachedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetUnattachedCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}
	mock.lockGetUnattached.RLock()
	calls = mock.calls.GetUnattached
	mock.lockGetUnattached.RUnlock()
	return calls
}

// MarkManualReservation calls MarkManualReservationFunc.
func (mock *GiftItemRepositoryInterfaceMock) MarkManualReservation(ctx context.Context, itemID pgtype.UUID, reservedByName string, note *string) (*models.GiftItem, error) {
	if mock.MarkManualReservationFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.MarkManualReservationFunc: method is nil but GiftItemRepositoryInterface.MarkManualReservation was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		ItemID         pgtype.UUID
		ReservedByName string
		Note           *string
	}{
		Ctx:            ctx,
		ItemID:         itemID,
		ReservedByName: reservedByName,
		Note:           note,
	}
	mock.lockMarkManualReservation.Lock()
	mock.calls.MarkManualReservation = append(mock.calls.MarkManualReservation, callInfo)
	mock.lockMarkManualReservation.Unlock()
	return mock.MarkManualReservationFunc(ctx, itemID, reservedByName, note)
}

// MarkManualReservationCalls gets all the calls that were made to MarkManualReservation.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.MarkManualReservationCalls())
func (mock *GiftItemRepositoryInterfaceMock) MarkManualReservationCalls() []struct {
	Ctx            context.Context
	ItemID         pgtype.UUID
	ReservedByName string
	Note           *string
} {
	var calls []struct {
		Ctx            context.Context
		ItemID         pgtype.UUID
		ReservedByName string
		Note           *string
	}
	mock.lockMarkManualReservation.RLock()
	calls = mock.calls.MarkManualReservation
	mock.lockMarkManualReservation.RUnlock()
	return calls
}

// SoftDelete calls SoftDeleteFunc.
func (mock *GiftItemRepositoryInterfaceMock) SoftDelete(ctx context.Context, id pgtype.UUID) error {
	if mock.SoftDeleteFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.SoftDeleteFunc: method is nil but GiftItemRepositoryInterface.SoftDelete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSoftDelete.Lock()
	mock.calls.SoftDelete = append(mock.calls.SoftDelete, callInfo)
	mock.lockSoftDelete.Unlock()
	return mock.SoftDeleteFunc(ctx, id)
}

// SoftDeleteCalls gets all the calls that were made to SoftDelete.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.SoftDeleteCalls())
func (mock *GiftItemRepositoryInterfaceMock) SoftDeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockSoftDelete.RLock()
	calls = mock.calls.SoftDelete
	mock.lockSoftDelete.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Update(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
	if mock.UpdateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateFunc: method is nil but GiftItemRepositoryInterface.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, giftItem)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateCalls() []struct {
	Ctx      context.Context
	GiftItem models.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateWithNewSchema calls UpdateWithNewSchemaFunc.
func (mock *GiftItemRepositoryInterfaceMock) UpdateWithNewSchema(ctx context.Context, giftItem *models.GiftItem) (*models.GiftItem, error) {
	if mock.UpdateWithNewSchemaFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateWithNewSchemaFunc: method is nil but GiftItemRepositoryInterface.UpdateWithNewSchema was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem *models.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdateWithNewSchema.Lock()
	mock.calls.UpdateWithNewSchema = append(mock.calls.UpdateWithNewSchema, callInfo)
	mock.lockUpdateWithNewSchema.Unlock()
	return mock.UpdateWithNewSchemaFunc(ctx, giftItem)
}

// UpdateWithNewSchemaCalls gets all the calls that were made to UpdateWithNewSchema.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateWithNewSchemaCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateWithNewSchemaCalls() []struct {
	Ctx      context.Context
	GiftItem *models.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem *models.GiftItem
	}
	mock.lockUpdateWithNewSchema.RLock()
	calls = mock.calls.UpdateWithNewSchema
	mock.lockUpdateWithNewSchema.RUnlock()
	return calls
}
