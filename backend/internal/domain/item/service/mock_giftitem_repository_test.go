// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	"wish-list/internal/app/database"
	"wish-list/internal/domain/item/models"
	"wish-list/internal/domain/item/repository"
)

// Ensure, that GiftItemRepositoryInterfaceMock does implement repository.GiftItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repository.GiftItemRepositoryInterface = &GiftItemRepositoryInterfaceMock{}

// GiftItemRepositoryInterfaceMock is a mock implementation of repository.GiftItemRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repository.GiftItemRepositoryInterface
//		mockedGiftItemRepositoryInterface := &GiftItemRepositoryInterfaceMock{
//			CreateWithOwnerFunc: func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
//				panic("mock out the CreateWithOwner method")
//			},
//			DeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the Delete method")
//			},
//			DeleteWithExecutorFunc: func(ctx context.Context, executor database.Executor, id pgtype.UUID) error {
//				panic("mock out the DeleteWithExecutor method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*models.GiftItem, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByOwnerPaginatedFunc: func(ctx context.Context, ownerID pgtype.UUID, filters repository.ItemFilters) (*repository.PaginatedResult, error) {
//				panic("mock out the GetByOwnerPaginated method")
//			},
//			GetByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) ([]*models.GiftItem, error) {
//				panic("mock out the GetByWishList method")
//			},
//			GetPublicWishListGiftItemsFunc: func(ctx context.Context, publicSlug string) ([]*models.GiftItem, error) {
//				panic("mock out the GetPublicWishListGiftItems method")
//			},
//			GetPublicWishListGiftItemsPaginatedFunc: func(ctx context.Context, publicSlug string, limit int, offset int) ([]*models.GiftItem, int, error) {
//				panic("mock out the GetPublicWishListGiftItemsPaginated method")
//			},
//			GetUnattachedFunc: func(ctx context.Context, ownerID pgtype.UUID) ([]*models.GiftItem, error) {
//				panic("mock out the GetUnattached method")
//			},
//			SoftDeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the SoftDelete method")
//			},
//			UpdateFunc: func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
//				panic("mock out the Update method")
//			},
//			UpdateWithNewSchemaFunc: func(ctx context.Context, giftItem *models.GiftItem) (*models.GiftItem, error) {
//				panic("mock out the UpdateWithNewSchema method")
//			},
//		}
//
//		// use mockedGiftItemRepositoryInterface in code that requires repository.GiftItemRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemRepositoryInterfaceMock struct {
	// CreateWithOwnerFunc mocks the CreateWithOwner method.
	CreateWithOwnerFunc func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteWithExecutorFunc mocks the DeleteWithExecutor method.
	DeleteWithExecutorFunc func(ctx context.Context, executor database.Executor, id pgtype.UUID) error

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*models.GiftItem, error)

	// GetByOwnerPaginatedFunc mocks the GetByOwnerPaginated method.
	GetByOwnerPaginatedFunc func(ctx context.Context, ownerID pgtype.UUID, filters repository.ItemFilters) (*repository.PaginatedResult, error)

	// GetByWishListFunc mocks the GetByWishList method.
	GetByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) ([]*models.GiftItem, error)

	// GetPublicWishListGiftItemsFunc mocks the GetPublicWishListGiftItems method.
	GetPublicWishListGiftItemsFunc func(ctx context.Context, publicSlug string) ([]*models.GiftItem, error)

	// GetPublicWishListGiftItemsPaginatedFunc mocks the GetPublicWishListGiftItemsPaginated method.
	GetPublicWishListGiftItemsPaginatedFunc func(ctx context.Context, publicSlug string, limit int, offset int) ([]*models.GiftItem, int, error)

	// GetUnattachedFunc mocks the GetUnattached method.
	GetUnattachedFunc func(ctx context.Context, ownerID pgtype.UUID) ([]*models.GiftItem, error)

	// SoftDeleteFunc mocks the SoftDelete method.
	SoftDeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error)

	// UpdateWithNewSchemaFunc mocks the UpdateWithNewSchema method.
	UpdateWithNewSchemaFunc func(ctx context.Context, giftItem *models.GiftItem) (*models.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateWithOwner holds details about calls to the CreateWithOwner method.
		CreateWithOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem models.GiftItem
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteWithExecutor holds details about calls to the DeleteWithExecutor method.
		DeleteWithExecutor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Executor is the executor argument value.
			Executor database.Executor
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByOwnerPaginated holds details about calls to the GetByOwnerPaginated method.
		GetByOwnerPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
			// Filters is the filters argument value.
			Filters repository.ItemFilters
		}
		// GetByWishList holds details about calls to the GetByWishList method.
		GetByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// GetPublicWishListGiftItems holds details about calls to the GetPublicWishListGiftItems method.
		GetPublicWishListGiftItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
		}
		// GetPublicWishListGiftItemsPaginated holds details about calls to the GetPublicWishListGiftItemsPaginated method.
		GetPublicWishListGiftItemsPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// GetUnattached holds details about calls to the GetUnattached method.
		GetUnattached []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
		}
		// SoftDelete holds details about calls to the SoftDelete method.
		SoftDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem models.GiftItem
		}
		// UpdateWithNewSchema holds details about calls to the UpdateWithNewSchema method.
		UpdateWithNewSchema []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem *models.GiftItem
		}
	}
	lockCreateWithOwner                     sync.RWMutex
	lockDelete                              sync.RWMutex
	lockDeleteWithExecutor                  sync.RWMutex
	lockGetByID                             sync.RWMutex
	lockGetByOwnerPaginated                 sync.RWMutex
	lockGetByWishList                       sync.RWMutex
	lockGetPublicWishListGiftItems          sync.RWMutex
	lockGetPublicWishListGiftItemsPaginated sync.RWMutex
	lockGetUnattached                       sync.RWMutex
	lockSoftDelete                          sync.RWMutex
	lockUpdate                              sync.RWMutex
	lockUpdateWithNewSchema                 sync.RWMutex
}

// CreateWithOwner calls CreateWithOwnerFunc.
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwner(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
	if mock.CreateWithOwnerFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CreateWithOwnerFunc: method is nil but GiftItemRepositoryInterface.CreateWithOwner was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockCreateWithOwner.Lock()
	mock.calls.CreateWithOwner = append(mock.calls.CreateWithOwner, callInfo)
	mock.lockCreateWithOwner.Unlock()
	return mock.CreateWithOwnerFunc(ctx, giftItem)
}

// CreateWithOwnerCalls gets all the calls that were made to CreateWithOwner.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CreateWithOwnerCalls())
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwnerCalls() []struct {
	Ctx      context.Context
	GiftItem models.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}
	mock.lockCreateWithOwner.RLock()
	calls = mock.calls.CreateWithOwner
	mock.lockCreateWithOwner.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *GiftItemRepositoryInterfaceMock) Delete(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteFunc: method is nil but GiftItemRepositoryInterface.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteWithExecutor calls DeleteWithExecutorFunc.
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithExecutor(ctx context.Context, executor database.Executor, id pgtype.UUID) error {
	if mock.DeleteWithExecutorFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteWithExecutorFunc: method is nil but GiftItemRepositoryInterface.DeleteWithExecutor was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Executor database.Executor
		ID       pgtype.UUID
	}{
		Ctx:      ctx,
		Executor: executor,
		ID:       id,
	}
	mock.lockDeleteWithExecutor.Lock()
	mock.calls.DeleteWithExecutor = append(mock.calls.DeleteWithExecutor, callInfo)
	mock.lockDeleteWithExecutor.Unlock()
	return mock.DeleteWithExecutorFunc(ctx, executor, id)
}

// DeleteWithExecutorCalls gets all the calls that were made to DeleteWithExecutor.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteWithExecutorCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithExecutorCalls() []struct {
	Ctx      context.Context
	Executor database.Executor
	ID       pgtype.UUID
} {
	var calls []struct {
		Ctx      context.Context
		Executor database.Executor
		ID       pgtype.UUID
	}
	mock.lockDeleteWithExecutor.RLock()
	calls = mock.calls.DeleteWithExecutor
	mock.lockDeleteWithExecutor.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*models.GiftItem, error) {
	if mock.GetByIDFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByIDFunc: method is nil but GiftItemRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByIDCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByOwnerPaginated calls GetByOwnerPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByOwnerPaginated(ctx context.Context, ownerID pgtype.UUID, filters repository.ItemFilters) (*repository.PaginatedResult, error) {
	if mock.GetByOwnerPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByOwnerPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetByOwnerPaginated was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
		Filters repository.ItemFilters
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
		Filters: filters,
	}
	mock.lockGetByOwnerPaginated.Lock()
	mock.calls.GetByOwnerPaginated = append(mock.calls.GetByOwnerPaginated, callInfo)
	mock.lockGetByOwnerPaginated.Unlock()
	return mock.GetByOwnerPaginatedFunc(ctx, ownerID, filters)
}

// GetByOwnerPaginatedCalls gets all the calls that were made to GetByOwnerPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByOwnerPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByOwnerPaginatedCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
	Filters repository.ItemFilters
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
		Filters repository.ItemFilters
	}
	mock.lockGetByOwnerPaginated.RLock()
	calls = mock.calls.GetByOwnerPaginated
	mock.lockGetByOwnerPaginated.RUnlock()
	return calls
}

// GetByWishList calls GetByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishList(ctx context.Context, wishlistID pgtype.UUID) ([]*models.GiftItem, error) {
	if mock.GetByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListFunc: method is nil but GiftItemRepositoryInterface.GetByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockGetByWishList.Lock()
	mock.calls.GetByWishList = append(mock.calls.GetByWishList, callInfo)
	mock.lockGetByWishList.Unlock()
	return mock.GetByWishListFunc(ctx, wishlistID)
}

// GetByWishListCalls gets all the calls that were made to GetByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockGetByWishList.RLock()
	calls = mock.calls.GetByWishList
	mock.lockGetByWishList.RUnlock()
	return calls
}

// GetPublicWishListGiftItems calls GetPublicWishListGiftItemsFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItems(ctx context.Context, publicSlug string) ([]*models.GiftItem, error) {
	if mock.GetPublicWishListGiftItemsFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItems was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
	}
	mock.lockGetPublicWishListGiftItems.Lock()
	mock.calls.GetPublicWishListGiftItems = append(mock.calls.GetPublicWishListGiftItems, callInfo)
	mock.lockGetPublicWishListGiftItems.Unlock()
	return mock.GetPublicWishListGiftItemsFunc(ctx, publicSlug)
}

// GetPublicWishListGiftItemsCalls gets all the calls that were made to GetPublicWishListGiftItems.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsCalls() []struct {
	Ctx        context.Context
	PublicSlug string
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
	}
	mock.lockGetPublicWishListGiftItems.RLock()
	calls = mock.calls.GetPublicWishListGiftItems
	mock.lockGetPublicWishListGiftItems.RUnlock()
	return calls
}

// GetPublicWishListGiftItemsPaginated calls GetPublicWishListGiftItemsPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsPaginated(ctx context.Context, publicSlug string, limit int, offset int) ([]*models.GiftItem, int, error) {
	if mock.GetPublicWishListGiftItemsPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItemsPaginated was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
		Limit      int
		Offset     int
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
		Limit:      limit,
		Offset:     offset,
	}
	mock.lockGetPublicWishListGiftItemsPaginated.Lock()
	mock.calls.GetPublicWishListGiftItemsPaginated = append(mock.calls.GetPublicWishListGiftItemsPaginated, callInfo)
	mock.lockGetPublicWishListGiftItemsPaginated.Unlock()
	return mock.GetPublicWishListGiftItemsPaginatedFunc(ctx, publicSlug, limit, offset)
}

// GetPublicWishListGiftItemsPaginatedCalls gets all the calls that were made to GetPublicWishListGiftItemsPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsPaginatedCalls() []struct {
	Ctx        context.Context
	PublicSlug string
	Limit      int
	Offset     int
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
		Limit      int
		Offset     int
	}
	mock.lockGetPublicWishListGiftItemsPaginated.RLock()
	calls = mock.calls.GetPublicWishListGiftItemsPaginated
	mock.lockGetPublicWishListGiftItemsPaginated.RUnlock()
	return calls
}

// GetUnattached calls GetUnattachedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetUnattached(ctx context.Context, ownerID pgtype.UUID) ([]*models.GiftItem, error) {
	if mock.GetUnattachedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetUnattachedFunc: method is nil but GiftItemRepositoryInterface.GetUnattached was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
	}
	mock.lockGetUnattached.Lock()
	mock.calls.GetUnattached = append(mock.calls.GetUnattached, callInfo)
	mock.lockGetUnattached.Unlock()
	return mock.GetUnattachedFunc(ctx, ownerID)
}

// GetUnattachedCalls gets all the calls that were made to GetUnattached.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetUnattachedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetUnattachedCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}
	mock.lockGetUnattached.RLock()
	calls = mock.calls.GetUnattached
	mock.lockGetUnattached.RUnlock()
	return calls
}

// SoftDelete calls SoftDeleteFunc.
func (mock *GiftItemRepositoryInterfaceMock) SoftDelete(ctx context.Context, id pgtype.UUID) error {
	if mock.SoftDeleteFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.SoftDeleteFunc: method is nil but GiftItemRepositoryInterface.SoftDelete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSoftDelete.Lock()
	mock.calls.SoftDelete = append(mock.calls.SoftDelete, callInfo)
	mock.lockSoftDelete.Unlock()
	return mock.SoftDeleteFunc(ctx, id)
}

// SoftDeleteCalls gets all the calls that were made to SoftDelete.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.SoftDeleteCalls())
func (mock *GiftItemRepositoryInterfaceMock) SoftDeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockSoftDelete.RLock()
	calls = mock.calls.SoftDelete
	mock.lockSoftDelete.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Update(ctx context.Context, giftItem models.GiftItem) (*models.GiftItem, error) {
	if mock.UpdateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateFunc: method is nil but GiftItemRepositoryInterface.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, giftItem)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateCalls() []struct {
	Ctx      context.Context
	GiftItem models.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem models.GiftItem
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateWithNewSchema calls UpdateWithNewSchemaFunc.
func (mock *GiftItemRepositoryInterfaceMock) UpdateWithNewSchema(ctx context.Context, giftItem *models.GiftItem) (*models.GiftItem, error) {
	if mock.UpdateWithNewSchemaFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateWithNewSchemaFunc: method is nil but GiftItemRepositoryInterface.UpdateWithNewSchema was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem *models.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdateWithNewSchema.Lock()
	mock.calls.UpdateWithNewSchema = append(mock.calls.UpdateWithNewSchema, callInfo)
	mock.lockUpdateWithNewSchema.Unlock()
	return mock.UpdateWithNewSchemaFunc(ctx, giftItem)
}

// UpdateWithNewSchemaCalls gets all the calls that were made to UpdateWithNewSchema.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateWithNewSchemaCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateWithNewSchemaCalls() []struct {
	Ctx      context.Context
	GiftItem *models.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem *models.GiftItem
	}
	mock.lockUpdateWithNewSchema.RLock()
	calls = mock.calls.UpdateWithNewSchema
	mock.lockUpdateWithNewSchema.RUnlock()
	return calls
}
