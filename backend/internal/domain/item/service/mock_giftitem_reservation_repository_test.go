// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	"wish-list/internal/domain/item/models"
	"wish-list/internal/domain/item/repository"
	reservationmodels "wish-list/internal/domain/reservation/models"
)

// Ensure, that GiftItemReservationRepositoryInterfaceMock does implement repository.GiftItemReservationRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repository.GiftItemReservationRepositoryInterface = &GiftItemReservationRepositoryInterfaceMock{}

// GiftItemReservationRepositoryInterfaceMock is a mock implementation of repository.GiftItemReservationRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemReservationRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repository.GiftItemReservationRepositoryInterface
//		mockedGiftItemReservationRepositoryInterface := &GiftItemReservationRepositoryInterfaceMock{
//			DeleteWithReservationNotificationFunc: func(ctx context.Context, giftItemID pgtype.UUID) ([]*reservationmodels.Reservation, error) {
//				panic("mock out the DeleteWithReservationNotification method")
//			},
//			ReserveFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*models.GiftItem, error) {
//				panic("mock out the Reserve method")
//			},
//			ReserveIfNotReservedFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*models.GiftItem, error) {
//				panic("mock out the ReserveIfNotReserved method")
//			},
//			UnreserveFunc: func(ctx context.Context, giftItemID pgtype.UUID) (*models.GiftItem, error) {
//				panic("mock out the Unreserve method")
//			},
//		}
//
//		// use mockedGiftItemReservationRepositoryInterface in code that requires repository.GiftItemReservationRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemReservationRepositoryInterfaceMock struct {
	// DeleteWithReservationNotificationFunc mocks the DeleteWithReservationNotification method.
	DeleteWithReservationNotificationFunc func(ctx context.Context, giftItemID pgtype.UUID) ([]*reservationmodels.Reservation, error)

	// ReserveFunc mocks the Reserve method.
	ReserveFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*models.GiftItem, error)

	// ReserveIfNotReservedFunc mocks the ReserveIfNotReserved method.
	ReserveIfNotReservedFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*models.GiftItem, error)

	// UnreserveFunc mocks the Unreserve method.
	UnreserveFunc func(ctx context.Context, giftItemID pgtype.UUID) (*models.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteWithReservationNotification holds details about calls to the DeleteWithReservationNotification method.
		DeleteWithReservationNotification []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
		// Reserve holds details about calls to the Reserve method.
		Reserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// ReserveIfNotReserved holds details about calls to the ReserveIfNotReserved method.
		ReserveIfNotReserved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// Unreserve holds details about calls to the Unreserve method.
		Unreserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
	}
	lockDeleteWithReservationNotification sync.RWMutex
	lockReserve                           sync.RWMutex
	lockReserveIfNotReserved              sync.RWMutex
	lockUnreserve                         sync.RWMutex
}

// DeleteWithReservationNotification calls DeleteWithReservationNotificationFunc.
func (mock *GiftItemReservationRepositoryInterfaceMock) DeleteWithReservationNotification(ctx context.Context, giftItemID pgtype.UUID) ([]*reservationmodels.Reservation, error) {
	if mock.DeleteWithReservationNotificationFunc == nil {
		panic("GiftItemReservationRepositoryInterfaceMock.DeleteWithReservationNotificationFunc: method is nil but GiftItemReservationRepositoryInterface.DeleteWithReservationNotification was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockDeleteWithReservationNotification.Lock()
	mock.calls.DeleteWithReservationNotification = append(mock.calls.DeleteWithReservationNotification, callInfo)
	mock.lockDeleteWithReservationNotification.Unlock()
	return mock.DeleteWithReservationNotificationFunc(ctx, giftItemID)
}

// DeleteWithReservationNotificationCalls gets all the calls that were made to DeleteWithReservationNotification.
// Check the length with:
//
//	len(mockedGiftItemReservationRepositoryInterface.DeleteWithReservationNotificationCalls())
func (mock *GiftItemReservationRepositoryInterfaceMock) DeleteWithReservationNotificationCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockDeleteWithReservationNotification.RLock()
	calls = mock.calls.DeleteWithReservationNotification
	mock.lockDeleteWithReservationNotification.RUnlock()
	return calls
}

// Reserve calls ReserveFunc.
func (mock *GiftItemReservationRepositoryInterfaceMock) Reserve(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*models.GiftItem, error) {
	if mock.ReserveFunc == nil {
		panic("GiftItemReservationRepositoryInterfaceMock.ReserveFunc: method is nil but GiftItemReservationRepositoryInterface.Reserve was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
		UserID:     userID,
	}
	mock.lockReserve.Lock()
	mock.calls.Reserve = append(mock.calls.Reserve, callInfo)
	mock.lockReserve.Unlock()
	return mock.ReserveFunc(ctx, giftItemID, userID)
}

// ReserveCalls gets all the calls that were made to Reserve.
// Check the length with:
//
//	len(mockedGiftItemReservationRepositoryInterface.ReserveCalls())
func (mock *GiftItemReservationRepositoryInterfaceMock) ReserveCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
	UserID     pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}
	mock.lockReserve.RLock()
	calls = mock.calls.Reserve
	mock.lockReserve.RUnlock()
	return calls
}

// ReserveIfNotReserved calls ReserveIfNotReservedFunc.
func (mock *GiftItemReservationRepositoryInterfaceMock) ReserveIfNotReserved(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*models.GiftItem, error) {
	if mock.ReserveIfNotReservedFunc == nil {
		panic("GiftItemReservationRepositoryInterfaceMock.ReserveIfNotReservedFunc: method is nil but GiftItemReservationRepositoryInterface.ReserveIfNotReserved was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
		UserID:     userID,
	}
	mock.lockReserveIfNotReserved.Lock()
	mock.calls.ReserveIfNotReserved = append(mock.calls.ReserveIfNotReserved, callInfo)
	mock.lockReserveIfNotReserved.Unlock()
	return mock.ReserveIfNotReservedFunc(ctx, giftItemID, userID)
}

// ReserveIfNotReservedCalls gets all the calls that were made to ReserveIfNotReserved.
// Check the length with:
//
//	len(mockedGiftItemReservationRepositoryInterface.ReserveIfNotReservedCalls())
func (mock *GiftItemReservationRepositoryInterfaceMock) ReserveIfNotReservedCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
	UserID     pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}
	mock.lockReserveIfNotReserved.RLock()
	calls = mock.calls.ReserveIfNotReserved
	mock.lockReserveIfNotReserved.RUnlock()
	return calls
}

// Unreserve calls UnreserveFunc.
func (mock *GiftItemReservationRepositoryInterfaceMock) Unreserve(ctx context.Context, giftItemID pgtype.UUID) (*models.GiftItem, error) {
	if mock.UnreserveFunc == nil {
		panic("GiftItemReservationRepositoryInterfaceMock.UnreserveFunc: method is nil but GiftItemReservationRepositoryInterface.Unreserve was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockUnreserve.Lock()
	mock.calls.Unreserve = append(mock.calls.Unreserve, callInfo)
	mock.lockUnreserve.Unlock()
	return mock.UnreserveFunc(ctx, giftItemID)
}

// UnreserveCalls gets all the calls that were made to Unreserve.
// Check the length with:
//
//	len(mockedGiftItemReservationRepositoryInterface.UnreserveCalls())
func (mock *GiftItemReservationRepositoryInterfaceMock) UnreserveCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockUnreserve.RLock()
	calls = mock.calls.Unreserve
	mock.lockUnreserve.RUnlock()
	return calls
}
