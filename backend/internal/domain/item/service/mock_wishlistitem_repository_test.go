// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"sync"

	"wish-list/internal/repositories"
	db "wish-list/internal/shared/db/models"

	"github.com/jackc/pgx/v5/pgtype"
)

// Ensure, that WishlistItemRepositoryInterfaceMock does implement repositories.WishlistItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repositories.WishlistItemRepositoryInterface = &WishlistItemRepositoryInterfaceMock{}

// WishlistItemRepositoryInterfaceMock is a mock implementation of repositories.WishlistItemRepositoryInterface.
//
//	func TestSomethingThatUsesWishlistItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repositories.WishlistItemRepositoryInterface
//		mockedWishlistItemRepositoryInterface := &WishlistItemRepositoryInterfaceMock{
//			AttachFunc: func(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) error {
//				panic("mock out the Attach method")
//			},
//			DetachFunc: func(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) error {
//				panic("mock out the Detach method")
//			},
//			DetachAllFunc: func(ctx context.Context, itemID pgtype.UUID) error {
//				panic("mock out the DetachAll method")
//			},
//			GetByWishlistFunc: func(ctx context.Context, wishlistID pgtype.UUID, page int, limit int) ([]*db.GiftItem, error) {
//				panic("mock out the GetByWishlist method")
//			},
//			GetByWishlistCountFunc: func(ctx context.Context, wishlistID pgtype.UUID) (int64, error) {
//				panic("mock out the GetByWishlistCount method")
//			},
//			GetWishlistsForItemFunc: func(ctx context.Context, itemID pgtype.UUID) ([]pgtype.UUID, error) {
//				panic("mock out the GetWishlistsForItem method")
//			},
//			IsAttachedFunc: func(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) (bool, error) {
//				panic("mock out the IsAttached method")
//			},
//		}
//
//		// use mockedWishlistItemRepositoryInterface in code that requires repositories.WishlistItemRepositoryInterface
//		// and then make assertions.
//
//	}
type WishlistItemRepositoryInterfaceMock struct {
	// AttachFunc mocks the Attach method.
	AttachFunc func(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) error

	// DetachFunc mocks the Detach method.
	DetachFunc func(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) error

	// DetachAllFunc mocks the DetachAll method.
	DetachAllFunc func(ctx context.Context, itemID pgtype.UUID) error

	// GetByWishlistFunc mocks the GetByWishlist method.
	GetByWishlistFunc func(ctx context.Context, wishlistID pgtype.UUID, page int, limit int) ([]*db.GiftItem, error)

	// GetByWishlistCountFunc mocks the GetByWishlistCount method.
	GetByWishlistCountFunc func(ctx context.Context, wishlistID pgtype.UUID) (int64, error)

	// GetWishlistsForItemFunc mocks the GetWishlistsForItem method.
	GetWishlistsForItemFunc func(ctx context.Context, itemID pgtype.UUID) ([]pgtype.UUID, error)

	// IsAttachedFunc mocks the IsAttached method.
	IsAttachedFunc func(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		Attach []struct {
			Ctx        context.Context
			WishlistID pgtype.UUID
			ItemID     pgtype.UUID
		}
		Detach []struct {
			Ctx        context.Context
			WishlistID pgtype.UUID
			ItemID     pgtype.UUID
		}
		DetachAll []struct {
			Ctx    context.Context
			ItemID pgtype.UUID
		}
		GetByWishlist []struct {
			Ctx        context.Context
			WishlistID pgtype.UUID
			Page       int
			Limit      int
		}
		GetByWishlistCount []struct {
			Ctx        context.Context
			WishlistID pgtype.UUID
		}
		GetWishlistsForItem []struct {
			Ctx    context.Context
			ItemID pgtype.UUID
		}
		IsAttached []struct {
			Ctx        context.Context
			WishlistID pgtype.UUID
			ItemID     pgtype.UUID
		}
	}
	lockAttach              sync.RWMutex
	lockDetach              sync.RWMutex
	lockDetachAll           sync.RWMutex
	lockGetByWishlist       sync.RWMutex
	lockGetByWishlistCount  sync.RWMutex
	lockGetWishlistsForItem sync.RWMutex
	lockIsAttached          sync.RWMutex
}

// Attach calls AttachFunc.
func (mock *WishlistItemRepositoryInterfaceMock) Attach(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) error {
	if mock.AttachFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.AttachFunc: method is nil but WishlistItemRepositoryInterface.Attach was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
		ItemID     pgtype.UUID
	}{Ctx: ctx, WishlistID: wishlistID, ItemID: itemID}
	mock.lockAttach.Lock()
	mock.calls.Attach = append(mock.calls.Attach, callInfo)
	mock.lockAttach.Unlock()
	return mock.AttachFunc(ctx, wishlistID, itemID)
}

// AttachCalls gets all the calls that were made to Attach.
func (mock *WishlistItemRepositoryInterfaceMock) AttachCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
	ItemID     pgtype.UUID
} {
	mock.lockAttach.RLock()
	calls := mock.calls.Attach
	mock.lockAttach.RUnlock()
	return calls
}

// Detach calls DetachFunc.
func (mock *WishlistItemRepositoryInterfaceMock) Detach(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) error {
	if mock.DetachFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.DetachFunc: method is nil but WishlistItemRepositoryInterface.Detach was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
		ItemID     pgtype.UUID
	}{Ctx: ctx, WishlistID: wishlistID, ItemID: itemID}
	mock.lockDetach.Lock()
	mock.calls.Detach = append(mock.calls.Detach, callInfo)
	mock.lockDetach.Unlock()
	return mock.DetachFunc(ctx, wishlistID, itemID)
}

// DetachCalls gets all the calls that were made to Detach.
func (mock *WishlistItemRepositoryInterfaceMock) DetachCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
	ItemID     pgtype.UUID
} {
	mock.lockDetach.RLock()
	calls := mock.calls.Detach
	mock.lockDetach.RUnlock()
	return calls
}

// DetachAll calls DetachAllFunc.
func (mock *WishlistItemRepositoryInterfaceMock) DetachAll(ctx context.Context, itemID pgtype.UUID) error {
	if mock.DetachAllFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.DetachAllFunc: method is nil but WishlistItemRepositoryInterface.DetachAll was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ItemID pgtype.UUID
	}{Ctx: ctx, ItemID: itemID}
	mock.lockDetachAll.Lock()
	mock.calls.DetachAll = append(mock.calls.DetachAll, callInfo)
	mock.lockDetachAll.Unlock()
	return mock.DetachAllFunc(ctx, itemID)
}

// DetachAllCalls gets all the calls that were made to DetachAll.
func (mock *WishlistItemRepositoryInterfaceMock) DetachAllCalls() []struct {
	Ctx    context.Context
	ItemID pgtype.UUID
} {
	mock.lockDetachAll.RLock()
	calls := mock.calls.DetachAll
	mock.lockDetachAll.RUnlock()
	return calls
}

// GetByWishlist calls GetByWishlistFunc.
func (mock *WishlistItemRepositoryInterfaceMock) GetByWishlist(ctx context.Context, wishlistID pgtype.UUID, page int, limit int) ([]*db.GiftItem, error) {
	if mock.GetByWishlistFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.GetByWishlistFunc: method is nil but WishlistItemRepositoryInterface.GetByWishlist was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
		Page       int
		Limit      int
	}{Ctx: ctx, WishlistID: wishlistID, Page: page, Limit: limit}
	mock.lockGetByWishlist.Lock()
	mock.calls.GetByWishlist = append(mock.calls.GetByWishlist, callInfo)
	mock.lockGetByWishlist.Unlock()
	return mock.GetByWishlistFunc(ctx, wishlistID, page, limit)
}

// GetByWishlistCalls gets all the calls that were made to GetByWishlist.
func (mock *WishlistItemRepositoryInterfaceMock) GetByWishlistCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
	Page       int
	Limit      int
} {
	mock.lockGetByWishlist.RLock()
	calls := mock.calls.GetByWishlist
	mock.lockGetByWishlist.RUnlock()
	return calls
}

// GetByWishlistCount calls GetByWishlistCountFunc.
func (mock *WishlistItemRepositoryInterfaceMock) GetByWishlistCount(ctx context.Context, wishlistID pgtype.UUID) (int64, error) {
	if mock.GetByWishlistCountFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.GetByWishlistCountFunc: method is nil but WishlistItemRepositoryInterface.GetByWishlistCount was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{Ctx: ctx, WishlistID: wishlistID}
	mock.lockGetByWishlistCount.Lock()
	mock.calls.GetByWishlistCount = append(mock.calls.GetByWishlistCount, callInfo)
	mock.lockGetByWishlistCount.Unlock()
	return mock.GetByWishlistCountFunc(ctx, wishlistID)
}

// GetByWishlistCountCalls gets all the calls that were made to GetByWishlistCount.
func (mock *WishlistItemRepositoryInterfaceMock) GetByWishlistCountCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	mock.lockGetByWishlistCount.RLock()
	calls := mock.calls.GetByWishlistCount
	mock.lockGetByWishlistCount.RUnlock()
	return calls
}

// GetWishlistsForItem calls GetWishlistsForItemFunc.
func (mock *WishlistItemRepositoryInterfaceMock) GetWishlistsForItem(ctx context.Context, itemID pgtype.UUID) ([]pgtype.UUID, error) {
	if mock.GetWishlistsForItemFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.GetWishlistsForItemFunc: method is nil but WishlistItemRepositoryInterface.GetWishlistsForItem was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ItemID pgtype.UUID
	}{Ctx: ctx, ItemID: itemID}
	mock.lockGetWishlistsForItem.Lock()
	mock.calls.GetWishlistsForItem = append(mock.calls.GetWishlistsForItem, callInfo)
	mock.lockGetWishlistsForItem.Unlock()
	return mock.GetWishlistsForItemFunc(ctx, itemID)
}

// GetWishlistsForItemCalls gets all the calls that were made to GetWishlistsForItem.
func (mock *WishlistItemRepositoryInterfaceMock) GetWishlistsForItemCalls() []struct {
	Ctx    context.Context
	ItemID pgtype.UUID
} {
	mock.lockGetWishlistsForItem.RLock()
	calls := mock.calls.GetWishlistsForItem
	mock.lockGetWishlistsForItem.RUnlock()
	return calls
}

// IsAttached calls IsAttachedFunc.
func (mock *WishlistItemRepositoryInterfaceMock) IsAttached(ctx context.Context, wishlistID pgtype.UUID, itemID pgtype.UUID) (bool, error) {
	if mock.IsAttachedFunc == nil {
		panic("WishlistItemRepositoryInterfaceMock.IsAttachedFunc: method is nil but WishlistItemRepositoryInterface.IsAttached was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
		ItemID     pgtype.UUID
	}{Ctx: ctx, WishlistID: wishlistID, ItemID: itemID}
	mock.lockIsAttached.Lock()
	mock.calls.IsAttached = append(mock.calls.IsAttached, callInfo)
	mock.lockIsAttached.Unlock()
	return mock.IsAttachedFunc(ctx, wishlistID, itemID)
}

// IsAttachedCalls gets all the calls that were made to IsAttached.
func (mock *WishlistItemRepositoryInterfaceMock) IsAttachedCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
	ItemID     pgtype.UUID
} {
	mock.lockIsAttached.RLock()
	calls := mock.calls.IsAttached
	mock.lockIsAttached.RUnlock()
	return calls
}
