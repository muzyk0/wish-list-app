// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	db "wish-list/internal/shared/db/models"
	"wish-list/internal/repositories"
)

// Ensure, that GiftItemRepositoryInterfaceMock does implement repositories.GiftItemRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repositories.GiftItemRepositoryInterface = &GiftItemRepositoryInterfaceMock{}

// GiftItemRepositoryInterfaceMock is a mock implementation of repositories.GiftItemRepositoryInterface.
//
//	func TestSomethingThatUsesGiftItemRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repositories.GiftItemRepositoryInterface
//		mockedGiftItemRepositoryInterface := &GiftItemRepositoryInterfaceMock{
//			CreateFunc: func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
//				panic("mock out the Create method")
//			},
//			CreateWithOwnerFunc: func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
//				panic("mock out the CreateWithOwner method")
//			},
//			DeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the Delete method")
//			},
//			DeleteWithExecutorFunc: func(ctx context.Context, executor db.Executor, id pgtype.UUID) error {
//				panic("mock out the DeleteWithExecutor method")
//			},
//			DeleteWithReservationNotificationFunc: func(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error) {
//				panic("mock out the DeleteWithReservationNotification method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*db.GiftItem, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByOwnerPaginatedFunc: func(ctx context.Context, ownerID pgtype.UUID, filters repositories.ItemFilters) (*repositories.PaginatedResult, error) {
//				panic("mock out the GetByOwnerPaginated method")
//			},
//			GetByWishListFunc: func(ctx context.Context, wishlistID pgtype.UUID) ([]*db.GiftItem, error) {
//				panic("mock out the GetByWishList method")
//			},
//			GetPublicWishListGiftItemsFunc: func(ctx context.Context, publicSlug string) ([]*db.GiftItem, error) {
//				panic("mock out the GetPublicWishListGiftItems method")
//			},
//			GetUnattachedFunc: func(ctx context.Context, ownerID pgtype.UUID) ([]*db.GiftItem, error) {
//				panic("mock out the GetUnattached method")
//			},
//			MarkAsPurchasedFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID, purchasedPrice pgtype.Numeric) (*db.GiftItem, error) {
//				panic("mock out the MarkAsPurchased method")
//			},
//			ReserveFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*db.GiftItem, error) {
//				panic("mock out the Reserve method")
//			},
//			ReserveIfNotReservedFunc: func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*db.GiftItem, error) {
//				panic("mock out the ReserveIfNotReserved method")
//			},
//			SoftDeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the SoftDelete method")
//			},
//			UnreserveFunc: func(ctx context.Context, giftItemID pgtype.UUID) (*db.GiftItem, error) {
//				panic("mock out the Unreserve method")
//			},
//			UpdateFunc: func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
//				panic("mock out the Update method")
//			},
//			UpdateWithNewSchemaFunc: func(ctx context.Context, giftItem *db.GiftItem) (*db.GiftItem, error) {
//				panic("mock out the UpdateWithNewSchema method")
//			},
//		}
//
//		// use mockedGiftItemRepositoryInterface in code that requires repositories.GiftItemRepositoryInterface
//		// and then make assertions.
//
//	}
type GiftItemRepositoryInterfaceMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error)

	// CreateWithOwnerFunc mocks the CreateWithOwner method.
	CreateWithOwnerFunc func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteWithExecutorFunc mocks the DeleteWithExecutor method.
	DeleteWithExecutorFunc func(ctx context.Context, executor db.Executor, id pgtype.UUID) error

	// DeleteWithReservationNotificationFunc mocks the DeleteWithReservationNotification method.
	DeleteWithReservationNotificationFunc func(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*db.GiftItem, error)

	// GetByOwnerPaginatedFunc mocks the GetByOwnerPaginated method.
	GetByOwnerPaginatedFunc func(ctx context.Context, ownerID pgtype.UUID, filters repositories.ItemFilters) (*repositories.PaginatedResult, error)

	// GetByWishListFunc mocks the GetByWishList method.
	GetByWishListFunc func(ctx context.Context, wishlistID pgtype.UUID) ([]*db.GiftItem, error)

	// GetPublicWishListGiftItemsFunc mocks the GetPublicWishListGiftItems method.
	GetPublicWishListGiftItemsFunc func(ctx context.Context, publicSlug string) ([]*db.GiftItem, error)

	// GetUnattachedFunc mocks the GetUnattached method.
	GetUnattachedFunc func(ctx context.Context, ownerID pgtype.UUID) ([]*db.GiftItem, error)

	// MarkAsPurchasedFunc mocks the MarkAsPurchased method.
	MarkAsPurchasedFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID, purchasedPrice pgtype.Numeric) (*db.GiftItem, error)

	// ReserveFunc mocks the Reserve method.
	ReserveFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*db.GiftItem, error)

	// ReserveIfNotReservedFunc mocks the ReserveIfNotReserved method.
	ReserveIfNotReservedFunc func(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*db.GiftItem, error)

	// SoftDeleteFunc mocks the SoftDelete method.
	SoftDeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// UnreserveFunc mocks the Unreserve method.
	UnreserveFunc func(ctx context.Context, giftItemID pgtype.UUID) (*db.GiftItem, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error)

	// UpdateWithNewSchemaFunc mocks the UpdateWithNewSchema method.
	UpdateWithNewSchemaFunc func(ctx context.Context, giftItem *db.GiftItem) (*db.GiftItem, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem db.GiftItem
		}
		// CreateWithOwner holds details about calls to the CreateWithOwner method.
		CreateWithOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem db.GiftItem
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteWithExecutor holds details about calls to the DeleteWithExecutor method.
		DeleteWithExecutor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Executor is the executor argument value.
			Executor db.Executor
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteWithReservationNotification holds details about calls to the DeleteWithReservationNotification method.
		DeleteWithReservationNotification []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByOwnerPaginated holds details about calls to the GetByOwnerPaginated method.
		GetByOwnerPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
			// Filters is the filters argument value.
			Filters repositories.ItemFilters
		}
		// GetByWishList holds details about calls to the GetByWishList method.
		GetByWishList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishlistID is the wishlistID argument value.
			WishlistID pgtype.UUID
		}
		// GetPublicWishListGiftItems holds details about calls to the GetPublicWishListGiftItems method.
		GetPublicWishListGiftItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
		}
		// GetUnattached holds details about calls to the GetUnattached method.
		GetUnattached []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
		}
		// MarkAsPurchased holds details about calls to the MarkAsPurchased method.
		MarkAsPurchased []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
			// PurchasedPrice is the purchasedPrice argument value.
			PurchasedPrice pgtype.Numeric
		}
		// Reserve holds details about calls to the Reserve method.
		Reserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// ReserveIfNotReserved holds details about calls to the ReserveIfNotReserved method.
		ReserveIfNotReserved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// SoftDelete holds details about calls to the SoftDelete method.
		SoftDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// Unreserve holds details about calls to the Unreserve method.
		Unreserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem db.GiftItem
		}
		// UpdateWithNewSchema holds details about calls to the UpdateWithNewSchema method.
		UpdateWithNewSchema []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItem is the giftItem argument value.
			GiftItem *db.GiftItem
		}
	}
	lockCreate                            sync.RWMutex
	lockCreateWithOwner                   sync.RWMutex
	lockDelete                            sync.RWMutex
	lockDeleteWithExecutor                sync.RWMutex
	lockDeleteWithReservationNotification sync.RWMutex
	lockGetByID                           sync.RWMutex
	lockGetByOwnerPaginated               sync.RWMutex
	lockGetByWishList                     sync.RWMutex
	lockGetPublicWishListGiftItems        sync.RWMutex
	lockGetUnattached                     sync.RWMutex
	lockMarkAsPurchased                   sync.RWMutex
	lockReserve                           sync.RWMutex
	lockReserveIfNotReserved              sync.RWMutex
	lockSoftDelete                        sync.RWMutex
	lockUnreserve                         sync.RWMutex
	lockUpdate                            sync.RWMutex
	lockUpdateWithNewSchema               sync.RWMutex
}

// Create calls CreateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Create(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
	if mock.CreateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CreateFunc: method is nil but GiftItemRepositoryInterface.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, giftItem)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CreateCalls())
func (mock *GiftItemRepositoryInterfaceMock) CreateCalls() []struct {
	Ctx      context.Context
	GiftItem db.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// CreateWithOwner calls CreateWithOwnerFunc.
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwner(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
	if mock.CreateWithOwnerFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.CreateWithOwnerFunc: method is nil but GiftItemRepositoryInterface.CreateWithOwner was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockCreateWithOwner.Lock()
	mock.calls.CreateWithOwner = append(mock.calls.CreateWithOwner, callInfo)
	mock.lockCreateWithOwner.Unlock()
	return mock.CreateWithOwnerFunc(ctx, giftItem)
}

// CreateWithOwnerCalls gets all the calls that were made to CreateWithOwner.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.CreateWithOwnerCalls())
func (mock *GiftItemRepositoryInterfaceMock) CreateWithOwnerCalls() []struct {
	Ctx      context.Context
	GiftItem db.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}
	mock.lockCreateWithOwner.RLock()
	calls = mock.calls.CreateWithOwner
	mock.lockCreateWithOwner.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *GiftItemRepositoryInterfaceMock) Delete(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteFunc: method is nil but GiftItemRepositoryInterface.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteWithExecutor calls DeleteWithExecutorFunc.
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithExecutor(ctx context.Context, executor db.Executor, id pgtype.UUID) error {
	if mock.DeleteWithExecutorFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteWithExecutorFunc: method is nil but GiftItemRepositoryInterface.DeleteWithExecutor was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Executor db.Executor
		ID       pgtype.UUID
	}{
		Ctx:      ctx,
		Executor: executor,
		ID:       id,
	}
	mock.lockDeleteWithExecutor.Lock()
	mock.calls.DeleteWithExecutor = append(mock.calls.DeleteWithExecutor, callInfo)
	mock.lockDeleteWithExecutor.Unlock()
	return mock.DeleteWithExecutorFunc(ctx, executor, id)
}

// DeleteWithExecutorCalls gets all the calls that were made to DeleteWithExecutor.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteWithExecutorCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithExecutorCalls() []struct {
	Ctx      context.Context
	Executor db.Executor
	ID       pgtype.UUID
} {
	var calls []struct {
		Ctx      context.Context
		Executor db.Executor
		ID       pgtype.UUID
	}
	mock.lockDeleteWithExecutor.RLock()
	calls = mock.calls.DeleteWithExecutor
	mock.lockDeleteWithExecutor.RUnlock()
	return calls
}

// DeleteWithReservationNotification calls DeleteWithReservationNotificationFunc.
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithReservationNotification(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error) {
	if mock.DeleteWithReservationNotificationFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.DeleteWithReservationNotificationFunc: method is nil but GiftItemRepositoryInterface.DeleteWithReservationNotification was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockDeleteWithReservationNotification.Lock()
	mock.calls.DeleteWithReservationNotification = append(mock.calls.DeleteWithReservationNotification, callInfo)
	mock.lockDeleteWithReservationNotification.Unlock()
	return mock.DeleteWithReservationNotificationFunc(ctx, giftItemID)
}

// DeleteWithReservationNotificationCalls gets all the calls that were made to DeleteWithReservationNotification.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.DeleteWithReservationNotificationCalls())
func (mock *GiftItemRepositoryInterfaceMock) DeleteWithReservationNotificationCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockDeleteWithReservationNotification.RLock()
	calls = mock.calls.DeleteWithReservationNotification
	mock.lockDeleteWithReservationNotification.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*db.GiftItem, error) {
	if mock.GetByIDFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByIDFunc: method is nil but GiftItemRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByIDCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByOwnerPaginated calls GetByOwnerPaginatedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByOwnerPaginated(ctx context.Context, ownerID pgtype.UUID, filters repositories.ItemFilters) (*repositories.PaginatedResult, error) {
	if mock.GetByOwnerPaginatedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByOwnerPaginatedFunc: method is nil but GiftItemRepositoryInterface.GetByOwnerPaginated was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
		Filters repositories.ItemFilters
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
		Filters: filters,
	}
	mock.lockGetByOwnerPaginated.Lock()
	mock.calls.GetByOwnerPaginated = append(mock.calls.GetByOwnerPaginated, callInfo)
	mock.lockGetByOwnerPaginated.Unlock()
	return mock.GetByOwnerPaginatedFunc(ctx, ownerID, filters)
}

// GetByOwnerPaginatedCalls gets all the calls that were made to GetByOwnerPaginated.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByOwnerPaginatedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByOwnerPaginatedCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
	Filters repositories.ItemFilters
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
		Filters repositories.ItemFilters
	}
	mock.lockGetByOwnerPaginated.RLock()
	calls = mock.calls.GetByOwnerPaginated
	mock.lockGetByOwnerPaginated.RUnlock()
	return calls
}

// GetByWishList calls GetByWishListFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetByWishList(ctx context.Context, wishlistID pgtype.UUID) ([]*db.GiftItem, error) {
	if mock.GetByWishListFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetByWishListFunc: method is nil but GiftItemRepositoryInterface.GetByWishList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}{
		Ctx:        ctx,
		WishlistID: wishlistID,
	}
	mock.lockGetByWishList.Lock()
	mock.calls.GetByWishList = append(mock.calls.GetByWishList, callInfo)
	mock.lockGetByWishList.Unlock()
	return mock.GetByWishListFunc(ctx, wishlistID)
}

// GetByWishListCalls gets all the calls that were made to GetByWishList.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetByWishListCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetByWishListCalls() []struct {
	Ctx        context.Context
	WishlistID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		WishlistID pgtype.UUID
	}
	mock.lockGetByWishList.RLock()
	calls = mock.calls.GetByWishList
	mock.lockGetByWishList.RUnlock()
	return calls
}

// GetPublicWishListGiftItems calls GetPublicWishListGiftItemsFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItems(ctx context.Context, publicSlug string) ([]*db.GiftItem, error) {
	if mock.GetPublicWishListGiftItemsFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetPublicWishListGiftItemsFunc: method is nil but GiftItemRepositoryInterface.GetPublicWishListGiftItems was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
	}
	mock.lockGetPublicWishListGiftItems.Lock()
	mock.calls.GetPublicWishListGiftItems = append(mock.calls.GetPublicWishListGiftItems, callInfo)
	mock.lockGetPublicWishListGiftItems.Unlock()
	return mock.GetPublicWishListGiftItemsFunc(ctx, publicSlug)
}

// GetPublicWishListGiftItemsCalls gets all the calls that were made to GetPublicWishListGiftItems.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetPublicWishListGiftItemsCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetPublicWishListGiftItemsCalls() []struct {
	Ctx        context.Context
	PublicSlug string
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
	}
	mock.lockGetPublicWishListGiftItems.RLock()
	calls = mock.calls.GetPublicWishListGiftItems
	mock.lockGetPublicWishListGiftItems.RUnlock()
	return calls
}

// GetUnattached calls GetUnattachedFunc.
func (mock *GiftItemRepositoryInterfaceMock) GetUnattached(ctx context.Context, ownerID pgtype.UUID) ([]*db.GiftItem, error) {
	if mock.GetUnattachedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.GetUnattachedFunc: method is nil but GiftItemRepositoryInterface.GetUnattached was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
	}
	mock.lockGetUnattached.Lock()
	mock.calls.GetUnattached = append(mock.calls.GetUnattached, callInfo)
	mock.lockGetUnattached.Unlock()
	return mock.GetUnattachedFunc(ctx, ownerID)
}

// GetUnattachedCalls gets all the calls that were made to GetUnattached.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.GetUnattachedCalls())
func (mock *GiftItemRepositoryInterfaceMock) GetUnattachedCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}
	mock.lockGetUnattached.RLock()
	calls = mock.calls.GetUnattached
	mock.lockGetUnattached.RUnlock()
	return calls
}

// MarkAsPurchased calls MarkAsPurchasedFunc.
func (mock *GiftItemRepositoryInterfaceMock) MarkAsPurchased(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID, purchasedPrice pgtype.Numeric) (*db.GiftItem, error) {
	if mock.MarkAsPurchasedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.MarkAsPurchasedFunc: method is nil but GiftItemRepositoryInterface.MarkAsPurchased was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		GiftItemID     pgtype.UUID
		UserID         pgtype.UUID
		PurchasedPrice pgtype.Numeric
	}{
		Ctx:            ctx,
		GiftItemID:     giftItemID,
		UserID:         userID,
		PurchasedPrice: purchasedPrice,
	}
	mock.lockMarkAsPurchased.Lock()
	mock.calls.MarkAsPurchased = append(mock.calls.MarkAsPurchased, callInfo)
	mock.lockMarkAsPurchased.Unlock()
	return mock.MarkAsPurchasedFunc(ctx, giftItemID, userID, purchasedPrice)
}

// MarkAsPurchasedCalls gets all the calls that were made to MarkAsPurchased.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.MarkAsPurchasedCalls())
func (mock *GiftItemRepositoryInterfaceMock) MarkAsPurchasedCalls() []struct {
	Ctx            context.Context
	GiftItemID     pgtype.UUID
	UserID         pgtype.UUID
	PurchasedPrice pgtype.Numeric
} {
	var calls []struct {
		Ctx            context.Context
		GiftItemID     pgtype.UUID
		UserID         pgtype.UUID
		PurchasedPrice pgtype.Numeric
	}
	mock.lockMarkAsPurchased.RLock()
	calls = mock.calls.MarkAsPurchased
	mock.lockMarkAsPurchased.RUnlock()
	return calls
}

// Reserve calls ReserveFunc.
func (mock *GiftItemRepositoryInterfaceMock) Reserve(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*db.GiftItem, error) {
	if mock.ReserveFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.ReserveFunc: method is nil but GiftItemRepositoryInterface.Reserve was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
		UserID:     userID,
	}
	mock.lockReserve.Lock()
	mock.calls.Reserve = append(mock.calls.Reserve, callInfo)
	mock.lockReserve.Unlock()
	return mock.ReserveFunc(ctx, giftItemID, userID)
}

// ReserveCalls gets all the calls that were made to Reserve.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.ReserveCalls())
func (mock *GiftItemRepositoryInterfaceMock) ReserveCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
	UserID     pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}
	mock.lockReserve.RLock()
	calls = mock.calls.Reserve
	mock.lockReserve.RUnlock()
	return calls
}

// ReserveIfNotReserved calls ReserveIfNotReservedFunc.
func (mock *GiftItemRepositoryInterfaceMock) ReserveIfNotReserved(ctx context.Context, giftItemID pgtype.UUID, userID pgtype.UUID) (*db.GiftItem, error) {
	if mock.ReserveIfNotReservedFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.ReserveIfNotReservedFunc: method is nil but GiftItemRepositoryInterface.ReserveIfNotReserved was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
		UserID:     userID,
	}
	mock.lockReserveIfNotReserved.Lock()
	mock.calls.ReserveIfNotReserved = append(mock.calls.ReserveIfNotReserved, callInfo)
	mock.lockReserveIfNotReserved.Unlock()
	return mock.ReserveIfNotReservedFunc(ctx, giftItemID, userID)
}

// ReserveIfNotReservedCalls gets all the calls that were made to ReserveIfNotReserved.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.ReserveIfNotReservedCalls())
func (mock *GiftItemRepositoryInterfaceMock) ReserveIfNotReservedCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
	UserID     pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
		UserID     pgtype.UUID
	}
	mock.lockReserveIfNotReserved.RLock()
	calls = mock.calls.ReserveIfNotReserved
	mock.lockReserveIfNotReserved.RUnlock()
	return calls
}

// SoftDelete calls SoftDeleteFunc.
func (mock *GiftItemRepositoryInterfaceMock) SoftDelete(ctx context.Context, id pgtype.UUID) error {
	if mock.SoftDeleteFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.SoftDeleteFunc: method is nil but GiftItemRepositoryInterface.SoftDelete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSoftDelete.Lock()
	mock.calls.SoftDelete = append(mock.calls.SoftDelete, callInfo)
	mock.lockSoftDelete.Unlock()
	return mock.SoftDeleteFunc(ctx, id)
}

// SoftDeleteCalls gets all the calls that were made to SoftDelete.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.SoftDeleteCalls())
func (mock *GiftItemRepositoryInterfaceMock) SoftDeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockSoftDelete.RLock()
	calls = mock.calls.SoftDelete
	mock.lockSoftDelete.RUnlock()
	return calls
}

// Unreserve calls UnreserveFunc.
func (mock *GiftItemRepositoryInterfaceMock) Unreserve(ctx context.Context, giftItemID pgtype.UUID) (*db.GiftItem, error) {
	if mock.UnreserveFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UnreserveFunc: method is nil but GiftItemRepositoryInterface.Unreserve was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockUnreserve.Lock()
	mock.calls.Unreserve = append(mock.calls.Unreserve, callInfo)
	mock.lockUnreserve.Unlock()
	return mock.UnreserveFunc(ctx, giftItemID)
}

// UnreserveCalls gets all the calls that were made to Unreserve.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UnreserveCalls())
func (mock *GiftItemRepositoryInterfaceMock) UnreserveCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockUnreserve.RLock()
	calls = mock.calls.Unreserve
	mock.lockUnreserve.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *GiftItemRepositoryInterfaceMock) Update(ctx context.Context, giftItem db.GiftItem) (*db.GiftItem, error) {
	if mock.UpdateFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateFunc: method is nil but GiftItemRepositoryInterface.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, giftItem)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateCalls() []struct {
	Ctx      context.Context
	GiftItem db.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem db.GiftItem
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// UpdateWithNewSchema calls UpdateWithNewSchemaFunc.
func (mock *GiftItemRepositoryInterfaceMock) UpdateWithNewSchema(ctx context.Context, giftItem *db.GiftItem) (*db.GiftItem, error) {
	if mock.UpdateWithNewSchemaFunc == nil {
		panic("GiftItemRepositoryInterfaceMock.UpdateWithNewSchemaFunc: method is nil but GiftItemRepositoryInterface.UpdateWithNewSchema was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GiftItem *db.GiftItem
	}{
		Ctx:      ctx,
		GiftItem: giftItem,
	}
	mock.lockUpdateWithNewSchema.Lock()
	mock.calls.UpdateWithNewSchema = append(mock.calls.UpdateWithNewSchema, callInfo)
	mock.lockUpdateWithNewSchema.Unlock()
	return mock.UpdateWithNewSchemaFunc(ctx, giftItem)
}

// UpdateWithNewSchemaCalls gets all the calls that were made to UpdateWithNewSchema.
// Check the length with:
//
//	len(mockedGiftItemRepositoryInterface.UpdateWithNewSchemaCalls())
func (mock *GiftItemRepositoryInterfaceMock) UpdateWithNewSchemaCalls() []struct {
	Ctx      context.Context
	GiftItem *db.GiftItem
} {
	var calls []struct {
		Ctx      context.Context
		GiftItem *db.GiftItem
	}
	mock.lockUpdateWithNewSchema.RLock()
	calls = mock.calls.UpdateWithNewSchema
	mock.lockUpdateWithNewSchema.RUnlock()
	return calls
}
