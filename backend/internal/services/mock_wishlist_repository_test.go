// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	"wish-list/internal/repositories"
	db "wish-list/internal/shared/db/models"
)

// Ensure, that WishListRepositoryInterfaceMock does implement repositories.WishListRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repositories.WishListRepositoryInterface = &WishListRepositoryInterfaceMock{}

// WishListRepositoryInterfaceMock is a mock implementation of repositories.WishListRepositoryInterface.
//
//	func TestSomethingThatUsesWishListRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repositories.WishListRepositoryInterface
//		mockedWishListRepositoryInterface := &WishListRepositoryInterfaceMock{
//			CreateFunc: func(ctx context.Context, wishList db.WishList) (*db.WishList, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the Delete method")
//			},
//			DeleteWithExecutorFunc: func(ctx context.Context, executor db.Executor, id pgtype.UUID) error {
//				panic("mock out the DeleteWithExecutor method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*db.WishList, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByOwnerFunc: func(ctx context.Context, ownerID pgtype.UUID) ([]*db.WishList, error) {
//				panic("mock out the GetByOwner method")
//			},
//			GetByOwnerWithItemCountFunc: func(ctx context.Context, ownerID pgtype.UUID) ([]*db.WishListWithItemCount, error) {
//				panic("mock out the GetByOwnerWithItemCount method")
//			},
//			GetByPublicSlugFunc: func(ctx context.Context, publicSlug string) (*db.WishList, error) {
//				panic("mock out the GetByPublicSlug method")
//			},
//			IncrementViewCountFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the IncrementViewCount method")
//			},
//			UpdateFunc: func(ctx context.Context, wishList db.WishList) (*db.WishList, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedWishListRepositoryInterface in code that requires repositories.WishListRepositoryInterface
//		// and then make assertions.
//
//	}
type WishListRepositoryInterfaceMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, wishList db.WishList) (*db.WishList, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteWithExecutorFunc mocks the DeleteWithExecutor method.
	DeleteWithExecutorFunc func(ctx context.Context, executor db.Executor, id pgtype.UUID) error

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*db.WishList, error)

	// GetByOwnerFunc mocks the GetByOwner method.
	GetByOwnerFunc func(ctx context.Context, ownerID pgtype.UUID) ([]*db.WishList, error)

	// GetByOwnerWithItemCountFunc mocks the GetByOwnerWithItemCount method.
	GetByOwnerWithItemCountFunc func(ctx context.Context, ownerID pgtype.UUID) ([]*db.WishListWithItemCount, error)

	// GetByPublicSlugFunc mocks the GetByPublicSlug method.
	GetByPublicSlugFunc func(ctx context.Context, publicSlug string) (*db.WishList, error)

	// IncrementViewCountFunc mocks the IncrementViewCount method.
	IncrementViewCountFunc func(ctx context.Context, id pgtype.UUID) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, wishList db.WishList) (*db.WishList, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishList is the wishList argument value.
			WishList db.WishList
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteWithExecutor holds details about calls to the DeleteWithExecutor method.
		DeleteWithExecutor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Executor is the executor argument value.
			Executor db.Executor
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByOwner holds details about calls to the GetByOwner method.
		GetByOwner []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
		}
		// GetByOwnerWithItemCount holds details about calls to the GetByOwnerWithItemCount method.
		GetByOwnerWithItemCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerID is the ownerID argument value.
			OwnerID pgtype.UUID
		}
		// GetByPublicSlug holds details about calls to the GetByPublicSlug method.
		GetByPublicSlug []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicSlug is the publicSlug argument value.
			PublicSlug string
		}
		// IncrementViewCount holds details about calls to the IncrementViewCount method.
		IncrementViewCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WishList is the wishList argument value.
			WishList db.WishList
		}
	}
	lockCreate                  sync.RWMutex
	lockDelete                  sync.RWMutex
	lockDeleteWithExecutor      sync.RWMutex
	lockGetByID                 sync.RWMutex
	lockGetByOwner              sync.RWMutex
	lockGetByOwnerWithItemCount sync.RWMutex
	lockGetByPublicSlug         sync.RWMutex
	lockIncrementViewCount      sync.RWMutex
	lockUpdate                  sync.RWMutex
}

// Create calls CreateFunc.
func (mock *WishListRepositoryInterfaceMock) Create(ctx context.Context, wishList db.WishList) (*db.WishList, error) {
	if mock.CreateFunc == nil {
		panic("WishListRepositoryInterfaceMock.CreateFunc: method is nil but WishListRepositoryInterface.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		WishList db.WishList
	}{
		Ctx:      ctx,
		WishList: wishList,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, wishList)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.CreateCalls())
func (mock *WishListRepositoryInterfaceMock) CreateCalls() []struct {
	Ctx      context.Context
	WishList db.WishList
} {
	var calls []struct {
		Ctx      context.Context
		WishList db.WishList
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *WishListRepositoryInterfaceMock) Delete(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteFunc == nil {
		panic("WishListRepositoryInterfaceMock.DeleteFunc: method is nil but WishListRepositoryInterface.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.DeleteCalls())
func (mock *WishListRepositoryInterfaceMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteWithExecutor calls DeleteWithExecutorFunc.
func (mock *WishListRepositoryInterfaceMock) DeleteWithExecutor(ctx context.Context, executor db.Executor, id pgtype.UUID) error {
	if mock.DeleteWithExecutorFunc == nil {
		panic("WishListRepositoryInterfaceMock.DeleteWithExecutorFunc: method is nil but WishListRepositoryInterface.DeleteWithExecutor was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Executor db.Executor
		ID       pgtype.UUID
	}{
		Ctx:      ctx,
		Executor: executor,
		ID:       id,
	}
	mock.lockDeleteWithExecutor.Lock()
	mock.calls.DeleteWithExecutor = append(mock.calls.DeleteWithExecutor, callInfo)
	mock.lockDeleteWithExecutor.Unlock()
	return mock.DeleteWithExecutorFunc(ctx, executor, id)
}

// DeleteWithExecutorCalls gets all the calls that were made to DeleteWithExecutor.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.DeleteWithExecutorCalls())
func (mock *WishListRepositoryInterfaceMock) DeleteWithExecutorCalls() []struct {
	Ctx      context.Context
	Executor db.Executor
	ID       pgtype.UUID
} {
	var calls []struct {
		Ctx      context.Context
		Executor db.Executor
		ID       pgtype.UUID
	}
	mock.lockDeleteWithExecutor.RLock()
	calls = mock.calls.DeleteWithExecutor
	mock.lockDeleteWithExecutor.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *WishListRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*db.WishList, error) {
	if mock.GetByIDFunc == nil {
		panic("WishListRepositoryInterfaceMock.GetByIDFunc: method is nil but WishListRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.GetByIDCalls())
func (mock *WishListRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByOwner calls GetByOwnerFunc.
func (mock *WishListRepositoryInterfaceMock) GetByOwner(ctx context.Context, ownerID pgtype.UUID) ([]*db.WishList, error) {
	if mock.GetByOwnerFunc == nil {
		panic("WishListRepositoryInterfaceMock.GetByOwnerFunc: method is nil but WishListRepositoryInterface.GetByOwner was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
	}
	mock.lockGetByOwner.Lock()
	mock.calls.GetByOwner = append(mock.calls.GetByOwner, callInfo)
	mock.lockGetByOwner.Unlock()
	return mock.GetByOwnerFunc(ctx, ownerID)
}

// GetByOwnerCalls gets all the calls that were made to GetByOwner.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.GetByOwnerCalls())
func (mock *WishListRepositoryInterfaceMock) GetByOwnerCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}
	mock.lockGetByOwner.RLock()
	calls = mock.calls.GetByOwner
	mock.lockGetByOwner.RUnlock()
	return calls
}

// GetByOwnerWithItemCount calls GetByOwnerWithItemCountFunc.
func (mock *WishListRepositoryInterfaceMock) GetByOwnerWithItemCount(ctx context.Context, ownerID pgtype.UUID) ([]*db.WishListWithItemCount, error) {
	if mock.GetByOwnerWithItemCountFunc == nil {
		panic("WishListRepositoryInterfaceMock.GetByOwnerWithItemCountFunc: method is nil but WishListRepositoryInterface.GetByOwnerWithItemCount was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}{
		Ctx:     ctx,
		OwnerID: ownerID,
	}
	mock.lockGetByOwnerWithItemCount.Lock()
	mock.calls.GetByOwnerWithItemCount = append(mock.calls.GetByOwnerWithItemCount, callInfo)
	mock.lockGetByOwnerWithItemCount.Unlock()
	return mock.GetByOwnerWithItemCountFunc(ctx, ownerID)
}

// GetByOwnerWithItemCountCalls gets all the calls that were made to GetByOwnerWithItemCount.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.GetByOwnerWithItemCountCalls())
func (mock *WishListRepositoryInterfaceMock) GetByOwnerWithItemCountCalls() []struct {
	Ctx     context.Context
	OwnerID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		OwnerID pgtype.UUID
	}
	mock.lockGetByOwnerWithItemCount.RLock()
	calls = mock.calls.GetByOwnerWithItemCount
	mock.lockGetByOwnerWithItemCount.RUnlock()
	return calls
}

// GetByPublicSlug calls GetByPublicSlugFunc.
func (mock *WishListRepositoryInterfaceMock) GetByPublicSlug(ctx context.Context, publicSlug string) (*db.WishList, error) {
	if mock.GetByPublicSlugFunc == nil {
		panic("WishListRepositoryInterfaceMock.GetByPublicSlugFunc: method is nil but WishListRepositoryInterface.GetByPublicSlug was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		PublicSlug string
	}{
		Ctx:        ctx,
		PublicSlug: publicSlug,
	}
	mock.lockGetByPublicSlug.Lock()
	mock.calls.GetByPublicSlug = append(mock.calls.GetByPublicSlug, callInfo)
	mock.lockGetByPublicSlug.Unlock()
	return mock.GetByPublicSlugFunc(ctx, publicSlug)
}

// GetByPublicSlugCalls gets all the calls that were made to GetByPublicSlug.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.GetByPublicSlugCalls())
func (mock *WishListRepositoryInterfaceMock) GetByPublicSlugCalls() []struct {
	Ctx        context.Context
	PublicSlug string
} {
	var calls []struct {
		Ctx        context.Context
		PublicSlug string
	}
	mock.lockGetByPublicSlug.RLock()
	calls = mock.calls.GetByPublicSlug
	mock.lockGetByPublicSlug.RUnlock()
	return calls
}

// IncrementViewCount calls IncrementViewCountFunc.
func (mock *WishListRepositoryInterfaceMock) IncrementViewCount(ctx context.Context, id pgtype.UUID) error {
	if mock.IncrementViewCountFunc == nil {
		panic("WishListRepositoryInterfaceMock.IncrementViewCountFunc: method is nil but WishListRepositoryInterface.IncrementViewCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockIncrementViewCount.Lock()
	mock.calls.IncrementViewCount = append(mock.calls.IncrementViewCount, callInfo)
	mock.lockIncrementViewCount.Unlock()
	return mock.IncrementViewCountFunc(ctx, id)
}

// IncrementViewCountCalls gets all the calls that were made to IncrementViewCount.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.IncrementViewCountCalls())
func (mock *WishListRepositoryInterfaceMock) IncrementViewCountCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockIncrementViewCount.RLock()
	calls = mock.calls.IncrementViewCount
	mock.lockIncrementViewCount.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *WishListRepositoryInterfaceMock) Update(ctx context.Context, wishList db.WishList) (*db.WishList, error) {
	if mock.UpdateFunc == nil {
		panic("WishListRepositoryInterfaceMock.UpdateFunc: method is nil but WishListRepositoryInterface.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		WishList db.WishList
	}{
		Ctx:      ctx,
		WishList: wishList,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, wishList)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedWishListRepositoryInterface.UpdateCalls())
func (mock *WishListRepositoryInterfaceMock) UpdateCalls() []struct {
	Ctx      context.Context
	WishList db.WishList
} {
	var calls []struct {
		Ctx      context.Context
		WishList db.WishList
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
