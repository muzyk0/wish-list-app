// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
	db "wish-list/internal/db/models"
	"wish-list/internal/repositories"
)

// Ensure, that ReservationRepositoryInterfaceMock does implement repositories.ReservationRepositoryInterface.
// If this is not the case, regenerate this file with moq.
var _ repositories.ReservationRepositoryInterface = &ReservationRepositoryInterfaceMock{}

// ReservationRepositoryInterfaceMock is a mock implementation of repositories.ReservationRepositoryInterface.
//
//	func TestSomethingThatUsesReservationRepositoryInterface(t *testing.T) {
//
//		// make and configure a mocked repositories.ReservationRepositoryInterface
//		mockedReservationRepositoryInterface := &ReservationRepositoryInterfaceMock{
//			CountUserReservationsFunc: func(ctx context.Context, userID pgtype.UUID) (int, error) {
//				panic("mock out the CountUserReservations method")
//			},
//			CreateFunc: func(ctx context.Context, reservation db.Reservation) (*db.Reservation, error) {
//				panic("mock out the Create method")
//			},
//			GetActiveReservationForGiftItemFunc: func(ctx context.Context, giftItemID pgtype.UUID) (*db.Reservation, error) {
//				panic("mock out the GetActiveReservationForGiftItem method")
//			},
//			GetByGiftItemFunc: func(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error) {
//				panic("mock out the GetByGiftItem method")
//			},
//			GetByIDFunc: func(ctx context.Context, id pgtype.UUID) (*db.Reservation, error) {
//				panic("mock out the GetByID method")
//			},
//			GetByTokenFunc: func(ctx context.Context, token pgtype.UUID) (*db.Reservation, error) {
//				panic("mock out the GetByToken method")
//			},
//			GetReservationsByUserFunc: func(ctx context.Context, userID pgtype.UUID, limit int, offset int) ([]*db.Reservation, error) {
//				panic("mock out the GetReservationsByUser method")
//			},
//			ListGuestReservationsWithDetailsFunc: func(ctx context.Context, token pgtype.UUID) ([]repositories.ReservationDetail, error) {
//				panic("mock out the ListGuestReservationsWithDetails method")
//			},
//			ListUserReservationsWithDetailsFunc: func(ctx context.Context, userID pgtype.UUID, limit int, offset int) ([]repositories.ReservationDetail, error) {
//				panic("mock out the ListUserReservationsWithDetails method")
//			},
//			UpdateStatusFunc: func(ctx context.Context, reservationID pgtype.UUID, status string, canceledAt pgtype.Timestamptz, cancelReason pgtype.Text) (*db.Reservation, error) {
//				panic("mock out the UpdateStatus method")
//			},
//			UpdateStatusByTokenFunc: func(ctx context.Context, token pgtype.UUID, status string, canceledAt pgtype.Timestamptz, cancelReason pgtype.Text) (*db.Reservation, error) {
//				panic("mock out the UpdateStatusByToken method")
//			},
//		}
//
//		// use mockedReservationRepositoryInterface in code that requires repositories.ReservationRepositoryInterface
//		// and then make assertions.
//
//	}
type ReservationRepositoryInterfaceMock struct {
	// CountUserReservationsFunc mocks the CountUserReservations method.
	CountUserReservationsFunc func(ctx context.Context, userID pgtype.UUID) (int, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, reservation db.Reservation) (*db.Reservation, error)

	// GetActiveReservationForGiftItemFunc mocks the GetActiveReservationForGiftItem method.
	GetActiveReservationForGiftItemFunc func(ctx context.Context, giftItemID pgtype.UUID) (*db.Reservation, error)

	// GetByGiftItemFunc mocks the GetByGiftItem method.
	GetByGiftItemFunc func(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id pgtype.UUID) (*db.Reservation, error)

	// GetByTokenFunc mocks the GetByToken method.
	GetByTokenFunc func(ctx context.Context, token pgtype.UUID) (*db.Reservation, error)

	// GetReservationsByUserFunc mocks the GetReservationsByUser method.
	GetReservationsByUserFunc func(ctx context.Context, userID pgtype.UUID, limit int, offset int) ([]*db.Reservation, error)

	// ListGuestReservationsWithDetailsFunc mocks the ListGuestReservationsWithDetails method.
	ListGuestReservationsWithDetailsFunc func(ctx context.Context, token pgtype.UUID) ([]repositories.ReservationDetail, error)

	// ListUserReservationsWithDetailsFunc mocks the ListUserReservationsWithDetails method.
	ListUserReservationsWithDetailsFunc func(ctx context.Context, userID pgtype.UUID, limit int, offset int) ([]repositories.ReservationDetail, error)

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(ctx context.Context, reservationID pgtype.UUID, status string, canceledAt pgtype.Timestamptz, cancelReason pgtype.Text) (*db.Reservation, error)

	// UpdateStatusByTokenFunc mocks the UpdateStatusByToken method.
	UpdateStatusByTokenFunc func(ctx context.Context, token pgtype.UUID, status string, canceledAt pgtype.Timestamptz, cancelReason pgtype.Text) (*db.Reservation, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountUserReservations holds details about calls to the CountUserReservations method.
		CountUserReservations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Reservation is the reservation argument value.
			Reservation db.Reservation
		}
		// GetActiveReservationForGiftItem holds details about calls to the GetActiveReservationForGiftItem method.
		GetActiveReservationForGiftItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
		// GetByGiftItem holds details about calls to the GetByGiftItem method.
		GetByGiftItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GiftItemID is the giftItemID argument value.
			GiftItemID pgtype.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetByToken holds details about calls to the GetByToken method.
		GetByToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token pgtype.UUID
		}
		// GetReservationsByUser holds details about calls to the GetReservationsByUser method.
		GetReservationsByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID pgtype.UUID
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// ListGuestReservationsWithDetails holds details about calls to the ListGuestReservationsWithDetails method.
		ListGuestReservationsWithDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token pgtype.UUID
		}
		// ListUserReservationsWithDetails holds details about calls to the ListUserReservationsWithDetails method.
		ListUserReservationsWithDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID pgtype.UUID
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReservationID is the reservationID argument value.
			ReservationID pgtype.UUID
			// Status is the status argument value.
			Status string
			// CanceledAt is the canceledAt argument value.
			CanceledAt pgtype.Timestamptz
			// CancelReason is the cancelReason argument value.
			CancelReason pgtype.Text
		}
		// UpdateStatusByToken holds details about calls to the UpdateStatusByToken method.
		UpdateStatusByToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token pgtype.UUID
			// Status is the status argument value.
			Status string
			// CanceledAt is the canceledAt argument value.
			CanceledAt pgtype.Timestamptz
			// CancelReason is the cancelReason argument value.
			CancelReason pgtype.Text
		}
	}
	lockCountUserReservations            sync.RWMutex
	lockCreate                           sync.RWMutex
	lockGetActiveReservationForGiftItem  sync.RWMutex
	lockGetByGiftItem                    sync.RWMutex
	lockGetByID                          sync.RWMutex
	lockGetByToken                       sync.RWMutex
	lockGetReservationsByUser            sync.RWMutex
	lockListGuestReservationsWithDetails sync.RWMutex
	lockListUserReservationsWithDetails  sync.RWMutex
	lockUpdateStatus                     sync.RWMutex
	lockUpdateStatusByToken              sync.RWMutex
}

// CountUserReservations calls CountUserReservationsFunc.
func (mock *ReservationRepositoryInterfaceMock) CountUserReservations(ctx context.Context, userID pgtype.UUID) (int, error) {
	if mock.CountUserReservationsFunc == nil {
		panic("ReservationRepositoryInterfaceMock.CountUserReservationsFunc: method is nil but ReservationRepositoryInterface.CountUserReservations was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID pgtype.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCountUserReservations.Lock()
	mock.calls.CountUserReservations = append(mock.calls.CountUserReservations, callInfo)
	mock.lockCountUserReservations.Unlock()
	return mock.CountUserReservationsFunc(ctx, userID)
}

// CountUserReservationsCalls gets all the calls that were made to CountUserReservations.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.CountUserReservationsCalls())
func (mock *ReservationRepositoryInterfaceMock) CountUserReservationsCalls() []struct {
	Ctx    context.Context
	UserID pgtype.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID pgtype.UUID
	}
	mock.lockCountUserReservations.RLock()
	calls = mock.calls.CountUserReservations
	mock.lockCountUserReservations.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *ReservationRepositoryInterfaceMock) Create(ctx context.Context, reservation db.Reservation) (*db.Reservation, error) {
	if mock.CreateFunc == nil {
		panic("ReservationRepositoryInterfaceMock.CreateFunc: method is nil but ReservationRepositoryInterface.Create was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Reservation db.Reservation
	}{
		Ctx:         ctx,
		Reservation: reservation,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, reservation)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.CreateCalls())
func (mock *ReservationRepositoryInterfaceMock) CreateCalls() []struct {
	Ctx         context.Context
	Reservation db.Reservation
} {
	var calls []struct {
		Ctx         context.Context
		Reservation db.Reservation
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// GetActiveReservationForGiftItem calls GetActiveReservationForGiftItemFunc.
func (mock *ReservationRepositoryInterfaceMock) GetActiveReservationForGiftItem(ctx context.Context, giftItemID pgtype.UUID) (*db.Reservation, error) {
	if mock.GetActiveReservationForGiftItemFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetActiveReservationForGiftItemFunc: method is nil but ReservationRepositoryInterface.GetActiveReservationForGiftItem was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockGetActiveReservationForGiftItem.Lock()
	mock.calls.GetActiveReservationForGiftItem = append(mock.calls.GetActiveReservationForGiftItem, callInfo)
	mock.lockGetActiveReservationForGiftItem.Unlock()
	return mock.GetActiveReservationForGiftItemFunc(ctx, giftItemID)
}

// GetActiveReservationForGiftItemCalls gets all the calls that were made to GetActiveReservationForGiftItem.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetActiveReservationForGiftItemCalls())
func (mock *ReservationRepositoryInterfaceMock) GetActiveReservationForGiftItemCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockGetActiveReservationForGiftItem.RLock()
	calls = mock.calls.GetActiveReservationForGiftItem
	mock.lockGetActiveReservationForGiftItem.RUnlock()
	return calls
}

// GetByGiftItem calls GetByGiftItemFunc.
func (mock *ReservationRepositoryInterfaceMock) GetByGiftItem(ctx context.Context, giftItemID pgtype.UUID) ([]*db.Reservation, error) {
	if mock.GetByGiftItemFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetByGiftItemFunc: method is nil but ReservationRepositoryInterface.GetByGiftItem was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}{
		Ctx:        ctx,
		GiftItemID: giftItemID,
	}
	mock.lockGetByGiftItem.Lock()
	mock.calls.GetByGiftItem = append(mock.calls.GetByGiftItem, callInfo)
	mock.lockGetByGiftItem.Unlock()
	return mock.GetByGiftItemFunc(ctx, giftItemID)
}

// GetByGiftItemCalls gets all the calls that were made to GetByGiftItem.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetByGiftItemCalls())
func (mock *ReservationRepositoryInterfaceMock) GetByGiftItemCalls() []struct {
	Ctx        context.Context
	GiftItemID pgtype.UUID
} {
	var calls []struct {
		Ctx        context.Context
		GiftItemID pgtype.UUID
	}
	mock.lockGetByGiftItem.RLock()
	calls = mock.calls.GetByGiftItem
	mock.lockGetByGiftItem.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *ReservationRepositoryInterfaceMock) GetByID(ctx context.Context, id pgtype.UUID) (*db.Reservation, error) {
	if mock.GetByIDFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetByIDFunc: method is nil but ReservationRepositoryInterface.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetByIDCalls())
func (mock *ReservationRepositoryInterfaceMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// GetByToken calls GetByTokenFunc.
func (mock *ReservationRepositoryInterfaceMock) GetByToken(ctx context.Context, token pgtype.UUID) (*db.Reservation, error) {
	if mock.GetByTokenFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetByTokenFunc: method is nil but ReservationRepositoryInterface.GetByToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token pgtype.UUID
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockGetByToken.Lock()
	mock.calls.GetByToken = append(mock.calls.GetByToken, callInfo)
	mock.lockGetByToken.Unlock()
	return mock.GetByTokenFunc(ctx, token)
}

// GetByTokenCalls gets all the calls that were made to GetByToken.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetByTokenCalls())
func (mock *ReservationRepositoryInterfaceMock) GetByTokenCalls() []struct {
	Ctx   context.Context
	Token pgtype.UUID
} {
	var calls []struct {
		Ctx   context.Context
		Token pgtype.UUID
	}
	mock.lockGetByToken.RLock()
	calls = mock.calls.GetByToken
	mock.lockGetByToken.RUnlock()
	return calls
}

// GetReservationsByUser calls GetReservationsByUserFunc.
func (mock *ReservationRepositoryInterfaceMock) GetReservationsByUser(ctx context.Context, userID pgtype.UUID, limit int, offset int) ([]*db.Reservation, error) {
	if mock.GetReservationsByUserFunc == nil {
		panic("ReservationRepositoryInterfaceMock.GetReservationsByUserFunc: method is nil but ReservationRepositoryInterface.GetReservationsByUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID pgtype.UUID
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		UserID: userID,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockGetReservationsByUser.Lock()
	mock.calls.GetReservationsByUser = append(mock.calls.GetReservationsByUser, callInfo)
	mock.lockGetReservationsByUser.Unlock()
	return mock.GetReservationsByUserFunc(ctx, userID, limit, offset)
}

// GetReservationsByUserCalls gets all the calls that were made to GetReservationsByUser.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.GetReservationsByUserCalls())
func (mock *ReservationRepositoryInterfaceMock) GetReservationsByUserCalls() []struct {
	Ctx    context.Context
	UserID pgtype.UUID
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		UserID pgtype.UUID
		Limit  int
		Offset int
	}
	mock.lockGetReservationsByUser.RLock()
	calls = mock.calls.GetReservationsByUser
	mock.lockGetReservationsByUser.RUnlock()
	return calls
}

// ListGuestReservationsWithDetails calls ListGuestReservationsWithDetailsFunc.
func (mock *ReservationRepositoryInterfaceMock) ListGuestReservationsWithDetails(ctx context.Context, token pgtype.UUID) ([]repositories.ReservationDetail, error) {
	if mock.ListGuestReservationsWithDetailsFunc == nil {
		panic("ReservationRepositoryInterfaceMock.ListGuestReservationsWithDetailsFunc: method is nil but ReservationRepositoryInterface.ListGuestReservationsWithDetails was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token pgtype.UUID
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockListGuestReservationsWithDetails.Lock()
	mock.calls.ListGuestReservationsWithDetails = append(mock.calls.ListGuestReservationsWithDetails, callInfo)
	mock.lockListGuestReservationsWithDetails.Unlock()
	return mock.ListGuestReservationsWithDetailsFunc(ctx, token)
}

// ListGuestReservationsWithDetailsCalls gets all the calls that were made to ListGuestReservationsWithDetails.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.ListGuestReservationsWithDetailsCalls())
func (mock *ReservationRepositoryInterfaceMock) ListGuestReservationsWithDetailsCalls() []struct {
	Ctx   context.Context
	Token pgtype.UUID
} {
	var calls []struct {
		Ctx   context.Context
		Token pgtype.UUID
	}
	mock.lockListGuestReservationsWithDetails.RLock()
	calls = mock.calls.ListGuestReservationsWithDetails
	mock.lockListGuestReservationsWithDetails.RUnlock()
	return calls
}

// ListUserReservationsWithDetails calls ListUserReservationsWithDetailsFunc.
func (mock *ReservationRepositoryInterfaceMock) ListUserReservationsWithDetails(ctx context.Context, userID pgtype.UUID, limit int, offset int) ([]repositories.ReservationDetail, error) {
	if mock.ListUserReservationsWithDetailsFunc == nil {
		panic("ReservationRepositoryInterfaceMock.ListUserReservationsWithDetailsFunc: method is nil but ReservationRepositoryInterface.ListUserReservationsWithDetails was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID pgtype.UUID
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		UserID: userID,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockListUserReservationsWithDetails.Lock()
	mock.calls.ListUserReservationsWithDetails = append(mock.calls.ListUserReservationsWithDetails, callInfo)
	mock.lockListUserReservationsWithDetails.Unlock()
	return mock.ListUserReservationsWithDetailsFunc(ctx, userID, limit, offset)
}

// ListUserReservationsWithDetailsCalls gets all the calls that were made to ListUserReservationsWithDetails.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.ListUserReservationsWithDetailsCalls())
func (mock *ReservationRepositoryInterfaceMock) ListUserReservationsWithDetailsCalls() []struct {
	Ctx    context.Context
	UserID pgtype.UUID
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		UserID pgtype.UUID
		Limit  int
		Offset int
	}
	mock.lockListUserReservationsWithDetails.RLock()
	calls = mock.calls.ListUserReservationsWithDetails
	mock.lockListUserReservationsWithDetails.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *ReservationRepositoryInterfaceMock) UpdateStatus(ctx context.Context, reservationID pgtype.UUID, status string, canceledAt pgtype.Timestamptz, cancelReason pgtype.Text) (*db.Reservation, error) {
	if mock.UpdateStatusFunc == nil {
		panic("ReservationRepositoryInterfaceMock.UpdateStatusFunc: method is nil but ReservationRepositoryInterface.UpdateStatus was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ReservationID pgtype.UUID
		Status        string
		CanceledAt    pgtype.Timestamptz
		CancelReason  pgtype.Text
	}{
		Ctx:           ctx,
		ReservationID: reservationID,
		Status:        status,
		CanceledAt:    canceledAt,
		CancelReason:  cancelReason,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(ctx, reservationID, status, canceledAt, cancelReason)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.UpdateStatusCalls())
func (mock *ReservationRepositoryInterfaceMock) UpdateStatusCalls() []struct {
	Ctx           context.Context
	ReservationID pgtype.UUID
	Status        string
	CanceledAt    pgtype.Timestamptz
	CancelReason  pgtype.Text
} {
	var calls []struct {
		Ctx           context.Context
		ReservationID pgtype.UUID
		Status        string
		CanceledAt    pgtype.Timestamptz
		CancelReason  pgtype.Text
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}

// UpdateStatusByToken calls UpdateStatusByTokenFunc.
func (mock *ReservationRepositoryInterfaceMock) UpdateStatusByToken(ctx context.Context, token pgtype.UUID, status string, canceledAt pgtype.Timestamptz, cancelReason pgtype.Text) (*db.Reservation, error) {
	if mock.UpdateStatusByTokenFunc == nil {
		panic("ReservationRepositoryInterfaceMock.UpdateStatusByTokenFunc: method is nil but ReservationRepositoryInterface.UpdateStatusByToken was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Token        pgtype.UUID
		Status       string
		CanceledAt   pgtype.Timestamptz
		CancelReason pgtype.Text
	}{
		Ctx:          ctx,
		Token:        token,
		Status:       status,
		CanceledAt:   canceledAt,
		CancelReason: cancelReason,
	}
	mock.lockUpdateStatusByToken.Lock()
	mock.calls.UpdateStatusByToken = append(mock.calls.UpdateStatusByToken, callInfo)
	mock.lockUpdateStatusByToken.Unlock()
	return mock.UpdateStatusByTokenFunc(ctx, token, status, canceledAt, cancelReason)
}

// UpdateStatusByTokenCalls gets all the calls that were made to UpdateStatusByToken.
// Check the length with:
//
//	len(mockedReservationRepositoryInterface.UpdateStatusByTokenCalls())
func (mock *ReservationRepositoryInterfaceMock) UpdateStatusByTokenCalls() []struct {
	Ctx          context.Context
	Token        pgtype.UUID
	Status       string
	CanceledAt   pgtype.Timestamptz
	CancelReason pgtype.Text
} {
	var calls []struct {
		Ctx          context.Context
		Token        pgtype.UUID
		Status       string
		CanceledAt   pgtype.Timestamptz
		CancelReason pgtype.Text
	}
	mock.lockUpdateStatusByToken.RLock()
	calls = mock.calls.UpdateStatusByToken
	mock.lockUpdateStatusByToken.RUnlock()
	return calls
}
